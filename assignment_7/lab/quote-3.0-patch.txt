diff --git a/src/analyze.c b/src/analyze.c
deleted file mode 100644
index e797248..0000000
--- a/src/analyze.c
+++ /dev/null
@@ -1,723 +0,0 @@
-/* Analyze file differences for GNU DIFF.
-
-   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006-2007,
-   2009-2010 Free Software Foundation, Inc.
-
-   This file is part of GNU DIFF.
-
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "diff.h"
-#include <cmpbuf.h>
-#include <error.h>
-#include <file-type.h>
-#include <xalloc.h>
-
-/* The core of the Diff algorithm.  */
-#define ELEMENT lin
-#define EQUAL(x,y) ((x) == (y))
-#define OFFSET lin
-#define EXTRA_CONTEXT_FIELDS /* none */
-#define NOTE_DELETE(c, xoff) (files[0].changed[files[0].realindexes[xoff]] = 1)
-#define NOTE_INSERT(c, yoff) (files[1].changed[files[1].realindexes[yoff]] = 1)
-#define USE_HEURISTIC 1
-#include <diffseq.h>
-
-/* Discard lines from one file that have no matches in the other file.
-
-   A line which is discarded will not be considered by the actual
-   comparison algorithm; it will be as if that line were not in the file.
-   The file's `realindexes' table maps virtual line numbers
-   (which don't count the discarded lines) into real line numbers;
-   this is how the actual comparison algorithm produces results
-   that are comprehensible when the discarded lines are counted.
-
-   When we discard a line, we also mark it as a deletion or insertion
-   so that it will be printed in the output.  */
-
-static void
-discard_confusing_lines (struct file_data filevec[])
-{
-  int f;
-  lin i;
-  char *discarded[2];
-  lin *equiv_count[2];
-  lin *p;
-
-  /* Allocate our results.  */
-  p = xmalloc ((filevec[0].buffered_lines + filevec[1].buffered_lines)
-	       * (2 * sizeof *p));
-  for (f = 0; f < 2; f++)
-    {
-      filevec[f].undiscarded = p;  p += filevec[f].buffered_lines;
-      filevec[f].realindexes = p;  p += filevec[f].buffered_lines;
-    }
-
-  /* Set up equiv_count[F][I] as the number of lines in file F
-     that fall in equivalence class I.  */
-
-  p = zalloc (filevec[0].equiv_max * (2 * sizeof *p));
-  equiv_count[0] = p;
-  equiv_count[1] = p + filevec[0].equiv_max;
-
-  for (i = 0; i < filevec[0].buffered_lines; ++i)
-    ++equiv_count[0][filevec[0].equivs[i]];
-  for (i = 0; i < filevec[1].buffered_lines; ++i)
-    ++equiv_count[1][filevec[1].equivs[i]];
-
-  /* Set up tables of which lines are going to be discarded.  */
-
-  discarded[0] = zalloc (filevec[0].buffered_lines
-			 + filevec[1].buffered_lines);
-  discarded[1] = discarded[0] + filevec[0].buffered_lines;
-
-  /* Mark to be discarded each line that matches no line of the other file.
-     If a line matches many lines, mark it as provisionally discardable.  */
-
-  for (f = 0; f < 2; f++)
-    {
-      size_t end = filevec[f].buffered_lines;
-      char *discards = discarded[f];
-      lin *counts = equiv_count[1 - f];
-      lin *equivs = filevec[f].equivs;
-      size_t many = 5;
-      size_t tem = end / 64;
-
-      /* Multiply MANY by approximate square root of number of lines.
-	 That is the threshold for provisionally discardable lines.  */
-      while ((tem = tem >> 2) > 0)
-	many *= 2;
-
-      for (i = 0; i < end; i++)
-	{
-	  lin nmatch;
-	  if (equivs[i] == 0)
-	    continue;
-	  nmatch = counts[equivs[i]];
-	  if (nmatch == 0)
-	    discards[i] = 1;
-	  else if (nmatch > many)
-	    discards[i] = 2;
-	}
-    }
-
-  /* Don't really discard the provisional lines except when they occur
-     in a run of discardables, with nonprovisionals at the beginning
-     and end.  */
-
-  for (f = 0; f < 2; f++)
-    {
-      lin end = filevec[f].buffered_lines;
-      register char *discards = discarded[f];
-
-      for (i = 0; i < end; i++)
-	{
-	  /* Cancel provisional discards not in middle of run of discards.  */
-	  if (discards[i] == 2)
-	    discards[i] = 0;
-	  else if (discards[i] != 0)
-	    {
-	      /* We have found a nonprovisional discard.  */
-	      register lin j;
-	      lin length;
-	      lin provisional = 0;
-
-	      /* Find end of this run of discardable lines.
-		 Count how many are provisionally discardable.  */
-	      for (j = i; j < end; j++)
-		{
-		  if (discards[j] == 0)
-		    break;
-		  if (discards[j] == 2)
-		    ++provisional;
-		}
-
-	      /* Cancel provisional discards at end, and shrink the run.  */
-	      while (j > i && discards[j - 1] == 2)
-		discards[--j] = 0, --provisional;
-
-	      /* Now we have the length of a run of discardable lines
-		 whose first and last are not provisional.  */
-	      length = j - i;
-
-	      /* If 1/4 of the lines in the run are provisional,
-		 cancel discarding of all provisional lines in the run.  */
-	      if (provisional * 4 > length)
-		{
-		  while (j > i)
-		    if (discards[--j] == 2)
-		      discards[j] = 0;
-		}
-	      else
-		{
-		  register lin consec;
-		  lin minimum = 1;
-		  lin tem = length >> 2;
-
-		  /* MINIMUM is approximate square root of LENGTH/4.
-		     A subrun of two or more provisionals can stand
-		     when LENGTH is at least 16.
-		     A subrun of 4 or more can stand when LENGTH >= 64.  */
-		  while (0 < (tem >>= 2))
-		    minimum <<= 1;
-		  minimum++;
-
-		  /* Cancel any subrun of MINIMUM or more provisionals
-		     within the larger run.  */
-		  for (j = 0, consec = 0; j < length; j++)
-		    if (discards[i + j] != 2)
-		      consec = 0;
-		    else if (minimum == ++consec)
-		      /* Back up to start of subrun, to cancel it all.  */
-		      j -= consec;
-		    else if (minimum < consec)
-		      discards[i + j] = 0;
-
-		  /* Scan from beginning of run
-		     until we find 3 or more nonprovisionals in a row
-		     or until the first nonprovisional at least 8 lines in.
-		     Until that point, cancel any provisionals.  */
-		  for (j = 0, consec = 0; j < length; j++)
-		    {
-		      if (j >= 8 && discards[i + j] == 1)
-			break;
-		      if (discards[i + j] == 2)
-			consec = 0, discards[i + j] = 0;
-		      else if (discards[i + j] == 0)
-			consec = 0;
-		      else
-			consec++;
-		      if (consec == 3)
-			break;
-		    }
-
-		  /* I advances to the last line of the run.  */
-		  i += length - 1;
-
-		  /* Same thing, from end.  */
-		  for (j = 0, consec = 0; j < length; j++)
-		    {
-		      if (j >= 8 && discards[i - j] == 1)
-			break;
-		      if (discards[i - j] == 2)
-			consec = 0, discards[i - j] = 0;
-		      else if (discards[i - j] == 0)
-			consec = 0;
-		      else
-			consec++;
-		      if (consec == 3)
-			break;
-		    }
-		}
-	    }
-	}
-    }
-
-  /* Actually discard the lines. */
-  for (f = 0; f < 2; f++)
-    {
-      char *discards = discarded[f];
-      lin end = filevec[f].buffered_lines;
-      lin j = 0;
-      for (i = 0; i < end; ++i)
-	if (minimal || discards[i] == 0)
-	  {
-	    filevec[f].undiscarded[j] = filevec[f].equivs[i];
-	    filevec[f].realindexes[j++] = i;
-	  }
-	else
-	  filevec[f].changed[i] = 1;
-      filevec[f].nondiscarded_lines = j;
-    }
-
-  free (discarded[0]);
-  free (equiv_count[0]);
-}
-
-/* Adjust inserts/deletes of identical lines to join changes
-   as much as possible.
-
-   We do something when a run of changed lines include a
-   line at one end and have an excluded, identical line at the other.
-   We are free to choose which identical line is included.
-   `compareseq' usually chooses the one at the beginning,
-   but usually it is cleaner to consider the following identical line
-   to be the "change".  */
-
-static void
-shift_boundaries (struct file_data filevec[])
-{
-  int f;
-
-  for (f = 0; f < 2; f++)
-    {
-      char *changed = filevec[f].changed;
-      char *other_changed = filevec[1 - f].changed;
-      lin const *equivs = filevec[f].equivs;
-      lin i = 0;
-      lin j = 0;
-      lin i_end = filevec[f].buffered_lines;
-
-      while (1)
-	{
-	  lin runlength, start, corresponding;
-
-	  /* Scan forwards to find beginning of another run of changes.
-	     Also keep track of the corresponding point in the other file.  */
-
-	  while (i < i_end && !changed[i])
-	    {
-	      while (other_changed[j++])
-		continue;
-	      i++;
-	    }
-
-	  if (i == i_end)
-	    break;
-
-	  start = i;
-
-	  /* Find the end of this run of changes.  */
-
-	  while (changed[++i])
-	    continue;
-	  while (other_changed[j])
-	    j++;
-
-	  do
-	    {
-	      /* Record the length of this run of changes, so that
-		 we can later determine whether the run has grown.  */
-	      runlength = i - start;
-
-	      /* Move the changed region back, so long as the
-		 previous unchanged line matches the last changed one.
-		 This merges with previous changed regions.  */
-
-	      while (start && equivs[start - 1] == equivs[i - 1])
-		{
-		  changed[--start] = 1;
-		  changed[--i] = 0;
-		  while (changed[start - 1])
-		    start--;
-		  while (other_changed[--j])
-		    continue;
-		}
-
-	      /* Set CORRESPONDING to the end of the changed run, at the last
-		 point where it corresponds to a changed run in the other file.
-		 CORRESPONDING == I_END means no such point has been found.  */
-	      corresponding = other_changed[j - 1] ? i : i_end;
-
-	      /* Move the changed region forward, so long as the
-		 first changed line matches the following unchanged one.
-		 This merges with following changed regions.
-		 Do this second, so that if there are no merges,
-		 the changed region is moved forward as far as possible.  */
-
-	      while (i != i_end && equivs[start] == equivs[i])
-		{
-		  changed[start++] = 0;
-		  changed[i++] = 1;
-		  while (changed[i])
-		    i++;
-		  while (other_changed[++j])
-		    corresponding = i;
-		}
-	    }
-	  while (runlength != i - start);
-
-	  /* If possible, move the fully-merged run of changes
-	     back to a corresponding run in the other file.  */
-
-	  while (corresponding < i)
-	    {
-	      changed[--start] = 1;
-	      changed[--i] = 0;
-	      while (other_changed[--j])
-		continue;
-	    }
-	}
-    }
-}
-
-/* Cons an additional entry onto the front of an edit script OLD.
-   LINE0 and LINE1 are the first affected lines in the two files (origin 0).
-   DELETED is the number of lines deleted here from file 0.
-   INSERTED is the number of lines inserted here in file 1.
-
-   If DELETED is 0 then LINE0 is the number of the line before
-   which the insertion was done; vice versa for INSERTED and LINE1.  */
-
-static struct change *
-add_change (lin line0, lin line1, lin deleted, lin inserted,
-	    struct change *old)
-{
-  struct change *new = xmalloc (sizeof *new);
-
-  new->line0 = line0;
-  new->line1 = line1;
-  new->inserted = inserted;
-  new->deleted = deleted;
-  new->link = old;
-  return new;
-}
-
-/* Scan the tables of which lines are inserted and deleted,
-   producing an edit script in reverse order.  */
-
-static struct change *
-build_reverse_script (struct file_data const filevec[])
-{
-  struct change *script = 0;
-  char *changed0 = filevec[0].changed;
-  char *changed1 = filevec[1].changed;
-  lin len0 = filevec[0].buffered_lines;
-  lin len1 = filevec[1].buffered_lines;
-
-  /* Note that changedN[lenN] does exist, and is 0.  */
-
-  lin i0 = 0, i1 = 0;
-
-  while (i0 < len0 || i1 < len1)
-    {
-      if (changed0[i0] | changed1[i1])
-	{
-	  lin line0 = i0, line1 = i1;
-
-	  /* Find # lines changed here in each file.  */
-	  while (changed0[i0]) ++i0;
-	  while (changed1[i1]) ++i1;
-
-	  /* Record this change.  */
-	  script = add_change (line0, line1, i0 - line0, i1 - line1, script);
-	}
-
-      /* We have reached lines in the two files that match each other.  */
-      i0++, i1++;
-    }
-
-  return script;
-}
-
-/* Scan the tables of which lines are inserted and deleted,
-   producing an edit script in forward order.  */
-
-static struct change *
-build_script (struct file_data const filevec[])
-{
-  struct change *script = 0;
-  char *changed0 = filevec[0].changed;
-  char *changed1 = filevec[1].changed;
-  lin i0 = filevec[0].buffered_lines, i1 = filevec[1].buffered_lines;
-
-  /* Note that changedN[-1] does exist, and is 0.  */
-
-  while (i0 >= 0 || i1 >= 0)
-    {
-      if (changed0[i0 - 1] | changed1[i1 - 1])
-	{
-	  lin line0 = i0, line1 = i1;
-
-	  /* Find # lines changed here in each file.  */
-	  while (changed0[i0 - 1]) --i0;
-	  while (changed1[i1 - 1]) --i1;
-
-	  /* Record this change.  */
-	  script = add_change (i0, i1, line0 - i0, line1 - i1, script);
-	}
-
-      /* We have reached lines in the two files that match each other.  */
-      i0--, i1--;
-    }
-
-  return script;
-}
-
-/* If CHANGES, briefly report that two files differed.
-   Return 2 if trouble, CHANGES otherwise.  */
-static int
-briefly_report (int changes, struct file_data const filevec[])
-{
-  if (changes)
-    {
-      char const *label0 = file_label[0] ? file_label[0] : filevec[0].name;
-      char const *label1 = file_label[1] ? file_label[1] : filevec[1].name;
-
-      if (brief)
-	message ("Files %s and %s differ\n", label0, label1);
-      else
-	{
-	  message ("Binary files %s and %s differ\n", label0, label1);
-	  changes = 2;
-	}
-    }
-
-  return changes;
-}
-
-/* Report the differences of two files.  */
-int
-diff_2_files (struct comparison *cmp)
-{
-  int f;
-  struct change *e, *p;
-  struct change *script;
-  int changes;
-
-
-  /* If we have detected that either file is binary,
-     compare the two files as binary.  This can happen
-     only when the first chunk is read.
-     Also, --brief without any --ignore-* options means
-     we can speed things up by treating the files as binary.  */
-
-  if (read_files (cmp->file, files_can_be_treated_as_binary))
-    {
-      /* Files with different lengths must be different.  */
-      if (cmp->file[0].stat.st_size != cmp->file[1].stat.st_size
-	  && (cmp->file[0].desc < 0 || S_ISREG (cmp->file[0].stat.st_mode))
-	  && (cmp->file[1].desc < 0 || S_ISREG (cmp->file[1].stat.st_mode)))
-	changes = 1;
-
-      /* Standard input equals itself.  */
-      else if (cmp->file[0].desc == cmp->file[1].desc)
-	changes = 0;
-
-      else
-	/* Scan both files, a buffer at a time, looking for a difference.  */
-	{
-	  /* Allocate same-sized buffers for both files.  */
-	  size_t lcm_max = PTRDIFF_MAX - 1;
-	  size_t buffer_size =
-	    buffer_lcm (sizeof (word),
-			buffer_lcm (STAT_BLOCKSIZE (cmp->file[0].stat),
-				    STAT_BLOCKSIZE (cmp->file[1].stat),
-				    lcm_max),
-			lcm_max);
-	  for (f = 0; f < 2; f++)
-	    cmp->file[f].buffer = xrealloc (cmp->file[f].buffer, buffer_size);
-
-	  for (;; cmp->file[0].buffered = cmp->file[1].buffered = 0)
-	    {
-	      /* Read a buffer's worth from both files.  */
-	      for (f = 0; f < 2; f++)
-		if (0 <= cmp->file[f].desc)
-		  file_block_read (&cmp->file[f],
-				   buffer_size - cmp->file[f].buffered);
-
-	      /* If the buffers differ, the files differ.  */
-	      if (cmp->file[0].buffered != cmp->file[1].buffered
-		  || memcmp (cmp->file[0].buffer,
-			     cmp->file[1].buffer,
-			     cmp->file[0].buffered))
-		{
-		  changes = 1;
-		  break;
-		}
-
-	      /* If we reach end of file, the files are the same.  */
-	      if (cmp->file[0].buffered != buffer_size)
-		{
-		  changes = 0;
-		  break;
-		}
-	    }
-	}
-
-      changes = briefly_report (changes, cmp->file);
-    }
-  else
-    {
-      struct context ctxt;
-      lin diags;
-      lin too_expensive;
-
-      /* Allocate vectors for the results of comparison:
-	 a flag for each line of each file, saying whether that line
-	 is an insertion or deletion.
-	 Allocate an extra element, always 0, at each end of each vector.  */
-
-      size_t s = cmp->file[0].buffered_lines + cmp->file[1].buffered_lines + 4;
-      char *flag_space = zalloc (s);
-      cmp->file[0].changed = flag_space + 1;
-      cmp->file[1].changed = flag_space + cmp->file[0].buffered_lines + 3;
-
-      /* Some lines are obviously insertions or deletions
-	 because they don't match anything.  Detect them now, and
-	 avoid even thinking about them in the main comparison algorithm.  */
-
-      discard_confusing_lines (cmp->file);
-
-      /* Now do the main comparison algorithm, considering just the
-	 undiscarded lines.  */
-
-      ctxt.xvec = cmp->file[0].undiscarded;
-      ctxt.yvec = cmp->file[1].undiscarded;
-      diags = (cmp->file[0].nondiscarded_lines
-	       + cmp->file[1].nondiscarded_lines + 3);
-      ctxt.fdiag = xmalloc (diags * (2 * sizeof *ctxt.fdiag));
-      ctxt.bdiag = ctxt.fdiag + diags;
-      ctxt.fdiag += cmp->file[1].nondiscarded_lines + 1;
-      ctxt.bdiag += cmp->file[1].nondiscarded_lines + 1;
-
-      ctxt.heuristic = speed_large_files;
-
-      /* Set TOO_EXPENSIVE to be approximate square root of input size,
-	 bounded below by 256.  */
-      too_expensive = 1;
-      for (;  diags != 0;  diags >>= 2)
-	too_expensive <<= 1;
-      ctxt.too_expensive = MAX (256, too_expensive);
-
-      files[0] = cmp->file[0];
-      files[1] = cmp->file[1];
-
-      compareseq (0, cmp->file[0].nondiscarded_lines,
-		  0, cmp->file[1].nondiscarded_lines, minimal, &ctxt);
-
-      free (ctxt.fdiag - (cmp->file[1].nondiscarded_lines + 1));
-
-      /* Modify the results slightly to make them prettier
-	 in cases where that can validly be done.  */
-
-      shift_boundaries (cmp->file);
-
-      /* Get the results of comparison in the form of a chain
-	 of `struct change's -- an edit script.  */
-
-      if (output_style == OUTPUT_ED)
-	script = build_reverse_script (cmp->file);
-      else
-	script = build_script (cmp->file);
-
-      /* Set CHANGES if we had any diffs.
-	 If some changes are ignored, we must scan the script to decide.  */
-      if (ignore_blank_lines || ignore_regexp.fastmap)
-	{
-	  struct change *next = script;
-	  changes = 0;
-
-	  while (next && changes == 0)
-	    {
-	      struct change *this, *end;
-	      lin first0, last0, first1, last1;
-
-	      /* Find a set of changes that belong together.  */
-	      this = next;
-	      end = find_change (next);
-
-	      /* Disconnect them from the rest of the changes, making them
-		 a hunk, and remember the rest for next iteration.  */
-	      next = end->link;
-	      end->link = 0;
-
-	      /* Determine whether this hunk is really a difference.  */
-	      if (analyze_hunk (this, &first0, &last0, &first1, &last1))
-		changes = 1;
-
-	      /* Reconnect the script so it will all be freed properly.  */
-	      end->link = next;
-	    }
-	}
-      else
-	changes = (script != 0);
-
-      if (brief)
-	changes = briefly_report (changes, cmp->file);
-      else
-	{
-	  if (changes || !no_diff_means_no_output)
-	    {
-	      /* Record info for starting up output,
-		 to be used if and when we have some output to print.  */
-	      setup_output (file_label[0] ? file_label[0] : cmp->file[0].name,
-			    file_label[1] ? file_label[1] : cmp->file[1].name,
-			    cmp->parent != 0);
-
-	      switch (output_style)
-		{
-		case OUTPUT_CONTEXT:
-		  print_context_script (script, false);
-		  break;
-
-		case OUTPUT_UNIFIED:
-		  print_context_script (script, true);
-		  break;
-
-		case OUTPUT_ED:
-		  print_ed_script (script);
-		  break;
-
-		case OUTPUT_FORWARD_ED:
-		  pr_forward_ed_script (script);
-		  break;
-
-		case OUTPUT_RCS:
-		  print_rcs_script (script);
-		  break;
-
-		case OUTPUT_NORMAL:
-		  print_normal_script (script);
-		  break;
-
-		case OUTPUT_IFDEF:
-		  print_ifdef_script (script);
-		  break;
-
-		case OUTPUT_SDIFF:
-		  print_sdiff_script (script);
-		  break;
-
-		default:
-		  abort ();
-		}
-
-	      finish_output ();
-	    }
-	}
-
-      free (cmp->file[0].undiscarded);
-
-      free (flag_space);
-
-      for (f = 0; f < 2; f++)
-	{
-	  free (cmp->file[f].equivs);
-	  free (cmp->file[f].linbuf + cmp->file[f].linbuf_base);
-	}
-
-      for (e = script; e; e = p)
-	{
-	  p = e->link;
-	  free (e);
-	}
-
-      if (! ROBUST_OUTPUT_STYLE (output_style))
-	for (f = 0; f < 2; ++f)
-	  if (cmp->file[f].missing_newline)
-	    {
-	      error (0, 0, "%s: %s\n",
-		     file_label[f] ? file_label[f] : cmp->file[f].name,
-		     _("No newline at end of file"));
-	      changes = 2;
-	    }
-    }
-
-  if (cmp->file[0].buffer != cmp->file[1].buffer)
-    free (cmp->file[0].buffer);
-  free (cmp->file[1].buffer);
-
-  return changes;
-}
diff --git a/src/cmp.c b/src/cmp.c
index 2455dc4..06b6e3d 100644
--- a/src/cmp.c
+++ b/src/cmp.c
@@ -36,7 +36,7 @@
 #include <xfreopen.h>
 #include <xstrtol.h>
 
-/* The official name of this program (e.g., no `g' prefix).  */
+/* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "cmp"
 
 #define AUTHORS \
@@ -185,7 +185,7 @@ usage (void)
 	  _("SKIP values may be followed by the following multiplicative suffixes:\n\
 kB 1000, K 1024, MB 1,000,000, M 1,048,576,\n\
 GB 1,000,000,000, G 1,073,741,824, and so on for T, P, E, Z, Y."),
-	  _("If a FILE is `-' or missing, read standard input."),
+	  _("If a FILE is '-' or missing, read standard input."),
 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
   emit_bug_reporting_address ();
 }
@@ -364,8 +364,8 @@ main (int argc, char **argv)
   return exit_status;
 }
 
-/* Compare the two files already open on `file_desc[0]' and `file_desc[1]',
-   using `buffer[0]' and `buffer[1]'.
+/* Compare the two files already open on 'file_desc[0]' and 'file_desc[1]',
+   using 'buffer[0]' and 'buffer[1]'.
    Return EXIT_SUCCESS if identical, EXIT_FAILURE if different,
    >1 if error.  */
 
@@ -377,7 +377,7 @@ cmp (void)
   uintmax_t remaining = bytes;	/* Remaining number of bytes to compare.  */
   size_t read0, read1;		/* Number of bytes read from each file. */
   size_t first_diff;		/* Offset (0...) in buffers of 1st diff. */
-  size_t smaller;		/* The lesser of `read0' and `read1'. */
+  size_t smaller;		/* The lesser of 'read0' and 'read1'. */
   word *buffer0 = buffer[0];
   word *buffer1 = buffer[1];
   char *buf0 = (char *) buffer0;
diff --git a/src/context.c b/src/context.c
deleted file mode 100644
index 0be8cc5..0000000
--- a/src/context.c
+++ /dev/null
@@ -1,493 +0,0 @@
-/* Context-format output routines for GNU DIFF.
-
-   Copyright (C) 1988-1989, 1991-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
-   Free Software Foundation, Inc.
-
-   This file is part of GNU DIFF.
-
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "diff.h"
-#include "c-ctype.h"
-#include <inttostr.h>
-#include <stat-time.h>
-#include <strftime.h>
-
-static char const *find_function (char const * const *, lin);
-static struct change *find_hunk (struct change *);
-static void mark_ignorable (struct change *);
-static void pr_context_hunk (struct change *);
-static void pr_unidiff_hunk (struct change *);
-
-/* Last place find_function started searching from.  */
-static lin find_function_last_search;
-
-/* The value find_function returned when it started searching there.  */
-static lin find_function_last_match;
-
-/* Print a label for a context diff, with a file name and date or a label.  */
-
-static void
-print_context_label (char const *mark,
-		     struct file_data *inf,
-		     char const *label)
-{
-  if (label)
-    fprintf (outfile, "%s %s\n", mark, label);
-  else
-    {
-      char buf[MAX (INT_STRLEN_BOUND (int) + 32,
-		    INT_STRLEN_BOUND (time_t) + 11)];
-      struct tm const *tm = localtime (&inf->stat.st_mtime);
-      int nsec = get_stat_mtime_ns (&inf->stat);
-      if (! (tm && nstrftime (buf, sizeof buf, time_format, tm, 0, nsec)))
-	{
-	  verify (TYPE_IS_INTEGER (time_t));
-	  if (LONG_MIN <= TYPE_MINIMUM (time_t)
-	      && TYPE_MAXIMUM (time_t) <= LONG_MAX)
-	    {
-	      long int sec = inf->stat.st_mtime;
-	      sprintf (buf, "%ld.%.9d", sec, nsec);
-	    }
-	  else if (TYPE_MAXIMUM (time_t) <= INTMAX_MAX)
-	    {
-	      intmax_t sec = inf->stat.st_mtime;
-	      sprintf (buf, "%"PRIdMAX".%.9d", sec, nsec);
-	    }
-	  else
-	    {
-	      uintmax_t sec = inf->stat.st_mtime;
-	      sprintf (buf, "%"PRIuMAX".%.9d", sec, nsec);
-	    }
-	}
-      fprintf (outfile, "%s %s\t%s\n", mark, inf->name, buf);
-    }
-}
-
-/* Print a header for a context diff, with the file names and dates.  */
-
-void
-print_context_header (struct file_data inf[], bool unidiff)
-{
-  if (unidiff)
-    {
-      print_context_label ("---", &inf[0], file_label[0]);
-      print_context_label ("+++", &inf[1], file_label[1]);
-    }
-  else
-    {
-      print_context_label ("***", &inf[0], file_label[0]);
-      print_context_label ("---", &inf[1], file_label[1]);
-    }
-}
-
-/* Print an edit script in context format.  */
-
-void
-print_context_script (struct change *script, bool unidiff)
-{
-  if (ignore_blank_lines || ignore_regexp.fastmap)
-    mark_ignorable (script);
-  else
-    {
-      struct change *e;
-      for (e = script; e; e = e->link)
-	e->ignore = false;
-    }
-
-  find_function_last_search = - files[0].prefix_lines;
-  find_function_last_match = LIN_MAX;
-
-  if (unidiff)
-    print_script (script, find_hunk, pr_unidiff_hunk);
-  else
-    print_script (script, find_hunk, pr_context_hunk);
-}
-
-/* Print a pair of line numbers with a comma, translated for file FILE.
-   If the second number is not greater, use the first in place of it.
-
-   Args A and B are internal line numbers.
-   We print the translated (real) line numbers.  */
-
-static void
-print_context_number_range (struct file_data const *file, lin a, lin b)
-{
-  long int trans_a, trans_b;
-  translate_range (file, a, b, &trans_a, &trans_b);
-
-  /* We can have B <= A in the case of a range of no lines.
-     In this case, we should print the line number before the range,
-     which is B.
-
-     POSIX 1003.1-2001 requires two line numbers separated by a comma
-     even if the line numbers are the same.  However, this does not
-     match existing practice and is surely an error in the
-     specification.  */
-
-  if (trans_b <= trans_a)
-    fprintf (outfile, "%ld", trans_b);
-  else
-    fprintf (outfile, "%ld,%ld", trans_a, trans_b);
-}
-
-/* Print FUNCTION in a context header.  */
-static void
-print_context_function (FILE *out, char const *function)
-{
-  int i, j;
-  putc (' ', out);
-  for (i = 0; c_isspace ((unsigned char) function[i]) && function[i] != '\n'; i++)
-    continue;
-  for (j = i; j < i + 40 && function[j] != '\n'; j++)
-    continue;
-  while (i < j && c_isspace ((unsigned char) function[j - 1]))
-    j--;
-  fwrite (function + i, sizeof (char), j - i, out);
-}
-
-/* Print a portion of an edit script in context format.
-   HUNK is the beginning of the portion to be printed.
-   The end is marked by a `link' that has been nulled out.
-
-   Prints out lines from both files, and precedes each
-   line with the appropriate flag-character.  */
-
-static void
-pr_context_hunk (struct change *hunk)
-{
-  lin first0, last0, first1, last1, i;
-  char const *prefix;
-  char const *function;
-  FILE *out;
-
-  /* Determine range of line numbers involved in each file.  */
-
-  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
-  if (! changes)
-    return;
-
-  /* Include a context's width before and after.  */
-
-  i = - files[0].prefix_lines;
-  first0 = MAX (first0 - context, i);
-  first1 = MAX (first1 - context, i);
-  if (last0 < files[0].valid_lines - context)
-    last0 += context;
-  else
-    last0 = files[0].valid_lines - 1;
-  if (last1 < files[1].valid_lines - context)
-    last1 += context;
-  else
-    last1 = files[1].valid_lines - 1;
-
-  /* If desired, find the preceding function definition line in file 0.  */
-  function = NULL;
-  if (function_regexp.fastmap)
-    function = find_function (files[0].linbuf, first0);
-
-  begin_output ();
-  out = outfile;
-
-  fputs ("***************", out);
-
-  if (function)
-    print_context_function (out, function);
-
-  fputs ("\n*** ", out);
-  print_context_number_range (&files[0], first0, last0);
-  fputs (" ****\n", out);
-
-  if (changes & OLD)
-    {
-      struct change *next = hunk;
-
-      for (i = first0; i <= last0; i++)
-	{
-	  /* Skip past changes that apply (in file 0)
-	     only to lines before line I.  */
-
-	  while (next && next->line0 + next->deleted <= i)
-	    next = next->link;
-
-	  /* Compute the marking for line I.  */
-
-	  prefix = " ";
-	  if (next && next->line0 <= i)
-	    /* The change NEXT covers this line.
-	       If lines were inserted here in file 1, this is "changed".
-	       Otherwise it is "deleted".  */
-	    prefix = (next->inserted > 0 ? "!" : "-");
-
-	  print_1_line (prefix, &files[0].linbuf[i]);
-	}
-    }
-
-  fputs ("--- ", out);
-  print_context_number_range (&files[1], first1, last1);
-  fputs (" ----\n", out);
-
-  if (changes & NEW)
-    {
-      struct change *next = hunk;
-
-      for (i = first1; i <= last1; i++)
-	{
-	  /* Skip past changes that apply (in file 1)
-	     only to lines before line I.  */
-
-	  while (next && next->line1 + next->inserted <= i)
-	    next = next->link;
-
-	  /* Compute the marking for line I.  */
-
-	  prefix = " ";
-	  if (next && next->line1 <= i)
-	    /* The change NEXT covers this line.
-	       If lines were deleted here in file 0, this is "changed".
-	       Otherwise it is "inserted".  */
-	    prefix = (next->deleted > 0 ? "!" : "+");
-
-	  print_1_line (prefix, &files[1].linbuf[i]);
-	}
-    }
-}
-
-/* Print a pair of line numbers with a comma, translated for file FILE.
-   If the second number is smaller, use the first in place of it.
-   If the numbers are equal, print just one number.
-
-   Args A and B are internal line numbers.
-   We print the translated (real) line numbers.  */
-
-static void
-print_unidiff_number_range (struct file_data const *file, lin a, lin b)
-{
-  long int trans_a, trans_b;
-  translate_range (file, a, b, &trans_a, &trans_b);
-
-  /* We can have B < A in the case of a range of no lines.
-     In this case, we print the line number before the range,
-     which is B.  It would be more logical to print A, but
-     'patch' expects B in order to detect diffs against empty files.  */
-  if (trans_b <= trans_a)
-    fprintf (outfile, trans_b < trans_a ? "%ld,0" : "%ld", trans_b);
-  else
-    fprintf (outfile, "%ld,%ld", trans_a, trans_b - trans_a + 1);
-}
-
-/* Print a portion of an edit script in unidiff format.
-   HUNK is the beginning of the portion to be printed.
-   The end is marked by a `link' that has been nulled out.
-
-   Prints out lines from both files, and precedes each
-   line with the appropriate flag-character.  */
-
-static void
-pr_unidiff_hunk (struct change *hunk)
-{
-  lin first0, last0, first1, last1;
-  lin i, j, k;
-  struct change *next;
-  char const *function;
-  FILE *out;
-
-  /* Determine range of line numbers involved in each file.  */
-
-  if (! analyze_hunk (hunk, &first0, &last0, &first1, &last1))
-    return;
-
-  /* Include a context's width before and after.  */
-
-  i = - files[0].prefix_lines;
-  first0 = MAX (first0 - context, i);
-  first1 = MAX (first1 - context, i);
-  if (last0 < files[0].valid_lines - context)
-    last0 += context;
-  else
-    last0 = files[0].valid_lines - 1;
-  if (last1 < files[1].valid_lines - context)
-    last1 += context;
-  else
-    last1 = files[1].valid_lines - 1;
-
-  /* If desired, find the preceding function definition line in file 0.  */
-  function = NULL;
-  if (function_regexp.fastmap)
-    function = find_function (files[0].linbuf, first0);
-
-  begin_output ();
-  out = outfile;
-
-  fputs ("@@ -", out);
-  print_unidiff_number_range (&files[0], first0, last0);
-  fputs (" +", out);
-  print_unidiff_number_range (&files[1], first1, last1);
-  fputs (" @@", out);
-
-  if (function)
-    print_context_function (out, function);
-
-  putc ('\n', out);
-
-  next = hunk;
-  i = first0;
-  j = first1;
-
-  while (i <= last0 || j <= last1)
-    {
-
-      /* If the line isn't a difference, output the context from file 0. */
-
-      if (!next || i < next->line0)
-	{
-	  char const *const *line = &files[0].linbuf[i++];
-	  if (! (suppress_blank_empty && **line == '\n'))
-	    putc (initial_tab ? '\t' : ' ', out);
-	  print_1_line (NULL, line);
-	  j++;
-	}
-      else
-	{
-	  /* For each difference, first output the deleted part. */
-
-	  k = next->deleted;
-	  while (k--)
-	    {
-	      char const * const *line = &files[0].linbuf[i++];
-	      putc ('-', out);
-	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
-		putc ('\t', out);
-	      print_1_line (NULL, line);
-	    }
-
-	  /* Then output the inserted part. */
-
-	  k = next->inserted;
-	  while (k--)
-	    {
-	      char const * const *line = &files[1].linbuf[j++];
-	      putc ('+', out);
-	      if (initial_tab && ! (suppress_blank_empty && **line == '\n'))
-		putc ('\t', out);
-	      print_1_line (NULL, line);
-	    }
-
-	  /* We're done with this hunk, so on to the next! */
-
-	  next = next->link;
-	}
-    }
-}
-
-/* Scan a (forward-ordered) edit script for the first place that more than
-   2*CONTEXT unchanged lines appear, and return a pointer
-   to the `struct change' for the last change before those lines.  */
-
-static struct change *
-find_hunk (struct change *start)
-{
-  struct change *prev;
-  lin top0, top1;
-  lin thresh;
-
-  /* Threshold distance is 2 * CONTEXT + 1 between two non-ignorable
-     changes, but only CONTEXT if one is ignorable.  Watch out for
-     integer overflow, though.  */
-  lin non_ignorable_threshold =
-    (LIN_MAX - 1) / 2 < context ? LIN_MAX : 2 * context + 1;
-  lin ignorable_threshold = context;
-
-  do
-    {
-      /* Compute number of first line in each file beyond this changed.  */
-      top0 = start->line0 + start->deleted;
-      top1 = start->line1 + start->inserted;
-      prev = start;
-      start = start->link;
-      thresh = (prev->ignore || (start && start->ignore)
-		? ignorable_threshold
-		: non_ignorable_threshold);
-      /* It is not supposed to matter which file we check in the end-test.
-	 If it would matter, crash.  */
-      if (start && start->line0 - top0 != start->line1 - top1)
-	abort ();
-    } while (start
-	     /* Keep going if less than THRESH lines
-		elapse before the affected line.  */
-	     && start->line0 - top0 < thresh);
-
-  return prev;
-}
-
-/* Set the `ignore' flag properly in each change in SCRIPT.
-   It should be 1 if all the lines inserted or deleted in that change
-   are ignorable lines.  */
-
-static void
-mark_ignorable (struct change *script)
-{
-  while (script)
-    {
-      struct change *next = script->link;
-      lin first0, last0, first1, last1;
-
-      /* Turn this change into a hunk: detach it from the others.  */
-      script->link = NULL;
-
-      /* Determine whether this change is ignorable.  */
-      script->ignore = ! analyze_hunk (script,
-				       &first0, &last0, &first1, &last1);
-
-      /* Reconnect the chain as before.  */
-      script->link = next;
-
-      /* Advance to the following change.  */
-      script = next;
-    }
-}
-
-/* Find the last function-header line in LINBUF prior to line number LINENUM.
-   This is a line containing a match for the regexp in `function_regexp'.
-   Return the address of the text, or NULL if no function-header is found.  */
-
-static char const *
-find_function (char const * const *linbuf, lin linenum)
-{
-  lin i = linenum;
-  lin last = find_function_last_search;
-  find_function_last_search = i;
-
-  while (last <= --i)
-    {
-      /* See if this line is what we want.  */
-      char const *line = linbuf[i];
-      size_t linelen = linbuf[i + 1] - line - 1;
-
-      /* FIXME: re_search's size args should be size_t, not int.  */
-      int len = MIN (linelen, INT_MAX);
-
-      if (0 <= re_search (&function_regexp, line, len, 0, len, NULL))
-	{
-	  find_function_last_match = i;
-	  return line;
-	}
-    }
-  /* If we search back to where we started searching the previous time,
-     find the line we found last time.  */
-  if (find_function_last_match != LIN_MAX)
-    return linbuf[find_function_last_match];
-
-  return NULL;
-}
diff --git a/src/diff.c b/src/diff.c
index cc1b611..5881bc0 100644
--- a/src/diff.c
+++ b/src/diff.c
@@ -40,7 +40,7 @@
 #include <xalloc.h>
 #include <xfreopen.h>
 
-/* The official name of this program (e.g., no `g' prefix).  */
+/* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "diff"
 
 #define AUTHORS \
@@ -57,9 +57,9 @@
 struct regexp_list
 {
   char *regexps;	/* chars representing disjunction of the regexps */
-  size_t len;		/* chars used in `regexps' */
-  size_t size;		/* size malloc'ed for `regexps'; 0 if not malloc'ed */
-  bool multiple_regexps;/* Does `regexps' represent a disjunction?  */
+  size_t len;		/* chars used in 'regexps' */
+  size_t size;		/* size malloc'ed for 'regexps'; 0 if not malloc'ed */
+  bool multiple_regexps;/* Does 'regexps' represent a disjunction?  */
   struct re_pattern_buffer *buf;
 };
 
@@ -92,13 +92,13 @@ enum { binary = true };
 
 /* When comparing directories, if a file appears only in one
    directory, treat it as present but empty in the other (-N).
-   Then `patch' would create the file with appropriate contents.  */
+   Then 'patch' would create the file with appropriate contents.  */
 static bool new_file;
 
 /* When comparing directories, if a file appears only in the second
    directory of the two, treat it as present but empty in the other
    (--unidirectional-new-file).
-   Then `patch' would create the file with appropriate contents.  */
+   Then 'patch' would create the file with appropriate contents.  */
 static bool unidirectional_new_file;
 
 /* Report files compared that are the same (-s).
@@ -870,11 +870,11 @@ static char const * const option_help_msgid[] = {
   -W NUM  --width=NUM  Output at most NUM (default 130) print columns.\n\
   --left-column  Output only the left column of common lines.\n\
   --suppress-common-lines  Do not output common lines."),
-  N_("-D NAME  --ifdef=NAME  Output merged file to show `#ifdef NAME' diffs."),
+  N_("-D NAME  --ifdef=NAME  Output merged file to show '#ifdef NAME' diffs."),
   N_("--GTYPE-group-format=GFMT  Similar, but format GTYPE input groups with GFMT."),
   N_("--line-format=LFMT  Similar, but format all input lines with LFMT."),
   N_("--LTYPE-line-format=LFMT  Similar, but format LTYPE input lines with LFMT."),
-  N_("  LTYPE is `old', `new', or `unchanged'.  GTYPE is LTYPE or `changed'."),
+  N_("  LTYPE is 'old', 'new', or 'unchanged'.  GTYPE is LTYPE or 'changed'."),
   N_("  GFMT may contain:\n\
     %<  lines from FILE1\n\
     %>  lines from FILE2\n\
@@ -895,7 +895,7 @@ static char const * const option_help_msgid[] = {
     %c'C'  the single character C\n\
     %c'\\OOO'  the character with octal code OOO"),
   "",
-  N_("-l  --paginate  Pass the output through `pr' to paginate it."),
+  N_("-l  --paginate  Pass the output through 'pr' to paginate it."),
   N_("-t  --expand-tabs  Expand tabs to spaces in output."),
   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
   N_("--tabsize=NUM  Tab stops are every NUM (default 8) print columns."),
@@ -918,9 +918,9 @@ static char const * const option_help_msgid[] = {
   N_("-v  --version  Output version info."),
   N_("--help  Output this help."),
   "",
-  N_("FILES are `FILE1 FILE2' or `DIR1 DIR2' or `DIR FILE...' or `FILE... DIR'."),
+  N_("FILES are 'FILE1 FILE2' or 'DIR1 DIR2' or 'DIR FILE...' or 'FILE... DIR'."),
   N_("If --from-file or --to-file is given, there are no restrictions on FILES."),
-  N_("If a FILE is `-', read standard input."),
+  N_("If a FILE is '-', read standard input."),
   N_("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."),
   0
 };
@@ -1159,7 +1159,7 @@ compare_files (struct comparison const *parent,
 	= dir_file_pathname (dir, last_component (fnm));
 
       if (STREQ (fnm, "-"))
-	fatal ("cannot compare `-' to a directory");
+	fatal ("cannot compare '-' to a directory");
 
       if (stat (filename, &cmp.file[dir_arg].stat) != 0)
 	{
diff --git a/src/diff3.c b/src/diff3.c
index 0f11fdc..2a2caef 100644
--- a/src/diff3.c
+++ b/src/diff3.c
@@ -35,7 +35,7 @@
 #include <xalloc.h>
 #include <xfreopen.h>
 
-/* The official name of this program (e.g., no `g' prefix).  */
+/* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "diff3"
 
 #define AUTHORS \
@@ -159,7 +159,7 @@ static bool overlap_only;
 /* If nonzero, show information for DIFF_2ND diffs.  */
 static bool show_2nd;
 
-/* If nonzero, include `:wq' at the end of the script
+/* If nonzero, include ':wq' at the end of the script
    to write out the file being edited.   */
 static bool finalwrite;
 
@@ -351,7 +351,7 @@ main (int argc, char **argv)
 	 file instead.  */
       common = 3 - common;
       if (STREQ (file[0], "-") || STREQ (file[common], "-"))
-	fatal ("`-' specified for more than one input file");
+	fatal ("'-' specified for more than one input file");
     }
 
   mapping[0] = 0;
@@ -412,7 +412,7 @@ try_help (char const *reason_msgid, char const *operand)
   if (reason_msgid)
     error (0, 0, _(reason_msgid), operand);
   error (EXIT_TROUBLE, 0,
-	 _("Try `%s --help' for more information."), program_name);
+	 _("Try '%s --help' for more information."), program_name);
   abort ();
 }
 
@@ -435,7 +435,7 @@ static char const * const option_help_msgid[] = {
   "",
   N_("-m  --merge  Output merged file instead of ed script (default -A)."),
   N_("-L LABEL  --label=LABEL  Use LABEL instead of file name."),
-  N_("-i  Append `w' and `q' commands to ed scripts."),
+  N_("-i  Append 'w' and 'q' commands to ed scripts."),
   N_("-a  --text  Treat all files as text."),
   N_("--strip-trailing-cr  Strip trailing carriage return on input."),
   N_("-T  --initial-tab  Make tabs line up by prepending a tab."),
@@ -460,7 +460,7 @@ usage (void)
     else
       putchar ('\n');
   printf ("\n%s\n%s\n",
-	  _("If a FILE is `-', read standard input."),
+	  _("If a FILE is '-', read standard input."),
 	  _("Exit status is 0 if successful, 1 if conflicts, 2 if trouble."));
   emit_bug_reporting_address ();
 }
@@ -1475,7 +1475,7 @@ undotlines (FILE *outputfile, bool leading_dot, long int start, lin num)
    around the problems involved with changing line numbers in an ed
    script.
 
-   As in `output_diff3', the variable MAPPING maps from file number
+   As in 'output_diff3', the variable MAPPING maps from file number
    according to the argument list to file number according to the diff
    passed.  All files listed below are in terms of the argument list.
    REV_MAPPING is the inverse of MAPPING.
diff --git a/src/dir.c b/src/dir.c
index 5b4eaec..92fac93 100644
--- a/src/dir.c
+++ b/src/dir.c
@@ -84,7 +84,7 @@ dir_read (struct file_data const *dir, struct dirdata *dirdata)
       dirdata->data = data = xmalloc (data_alloc);
 
       /* Read the directory entries, and insert the subfiles
-	 into the `data' table.  */
+	 into the 'data' table.  */
 
       while ((errno = 0, (next = readdir (reading)) != 0))
 	{
@@ -125,7 +125,7 @@ dir_read (struct file_data const *dir, struct dirdata *dirdata)
 #endif
     }
 
-  /* Create the `names' table from the `data' table.  */
+  /* Create the 'names' table from the 'data' table.  */
   if (PTRDIFF_MAX / sizeof *names - 1 <= nnames)
     xalloc_die ();
   dirdata->names = names = xmalloc ((nnames + 1) * sizeof *names);
@@ -234,7 +234,7 @@ diff_dirs (struct comparison const *cmp,
 	qsort (names[i], dirdata[i].nnames, sizeof *dirdata[i].names,
 	       compare_names_for_qsort);
 
-      /* If `-S name' was given, and this is the topmost level of comparison,
+      /* If '-S name' was given, and this is the topmost level of comparison,
 	 ignore all file names less than the specified starting name.  */
 
       if (starting_file && ! cmp->parent)
diff --git a/src/ifdef.c b/src/ifdef.c
deleted file mode 100644
index a48f830..0000000
--- a/src/ifdef.c
+++ /dev/null
@@ -1,430 +0,0 @@
-/* #ifdef-format output routines for GNU DIFF.
-
-   Copyright (C) 1989, 1991-1994, 2001-2002, 2004, 2006, 2009-2010 Free
-   Software Foundation, Inc.
-
-   This file is part of GNU DIFF.
-
-   GNU DIFF is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY.  No author or distributor
-   accepts responsibility to anyone for the consequences of using it
-   or for whether it serves any particular purpose or works at all,
-   unless he says so in writing.  Refer to the GNU General Public
-   License for full details.
-
-   Everyone is granted permission to copy, modify and redistribute
-   GNU DIFF, but only under the conditions described in the
-   GNU General Public License.   A copy of this license is
-   supposed to have been given to you along with GNU DIFF so you
-   can know your rights and responsibilities.  It should be in a
-   file named COPYING.  Among other things, the copyright notice
-   and this notice must be preserved on all copies.  */
-
-#include "diff.h"
-
-#include <xalloc.h>
-
-struct group
-{
-  struct file_data const *file;
-  lin from, upto; /* start and limit lines for this group of lines */
-};
-
-static char const *format_group (FILE *, char const *, char,
-				 struct group const *);
-static char const *do_printf_spec (FILE *, char const *,
-				   struct file_data const *, lin,
-				   struct group const *);
-static char const *scan_char_literal (char const *, char *);
-static lin groups_letter_value (struct group const *, char);
-static void format_ifdef (char const *, lin, lin, lin, lin);
-static void print_ifdef_hunk (struct change *);
-static void print_ifdef_lines (FILE *, char const *, struct group const *);
-
-static lin next_line0;
-static lin next_line1;
-
-/* Print the edit-script SCRIPT as a merged #ifdef file.  */
-
-void
-print_ifdef_script (struct change *script)
-{
-  next_line0 = next_line1 = - files[0].prefix_lines;
-  print_script (script, find_change, print_ifdef_hunk);
-  if (next_line0 < files[0].valid_lines
-      || next_line1 < files[1].valid_lines)
-    {
-      begin_output ();
-      format_ifdef (group_format[UNCHANGED],
-		    next_line0, files[0].valid_lines,
-		    next_line1, files[1].valid_lines);
-    }
-}
-
-/* Print a hunk of an ifdef diff.
-   This is a contiguous portion of a complete edit script,
-   describing changes in consecutive lines.  */
-
-static void
-print_ifdef_hunk (struct change *hunk)
-{
-  lin first0, last0, first1, last1;
-
-  /* Determine range of line numbers involved in each file.  */
-  enum changes changes = analyze_hunk (hunk, &first0, &last0, &first1, &last1);
-  if (!changes)
-    return;
-
-  begin_output ();
-
-  /* Print lines up to this change.  */
-  if (next_line0 < first0 || next_line1 < first1)
-    format_ifdef (group_format[UNCHANGED],
-		  next_line0, first0,
-		  next_line1, first1);
-
-  /* Print this change.  */
-  next_line0 = last0 + 1;
-  next_line1 = last1 + 1;
-  format_ifdef (group_format[changes],
-		first0, next_line0,
-		first1, next_line1);
-}
-
-/* Print a set of lines according to FORMAT.
-   Lines BEG0 up to END0 are from the first file;
-   lines BEG1 up to END1 are from the second file.  */
-
-static void
-format_ifdef (char const *format, lin beg0, lin end0, lin beg1, lin end1)
-{
-  struct group groups[2];
-
-  groups[0].file = &files[0];
-  groups[0].from = beg0;
-  groups[0].upto = end0;
-  groups[1].file = &files[1];
-  groups[1].from = beg1;
-  groups[1].upto = end1;
-  format_group (outfile, format, 0, groups);
-}
-
-/* Print to file OUT a set of lines according to FORMAT.
-   The format ends at the first free instance of ENDCHAR.
-   Yield the address of the terminating character.
-   GROUPS specifies which lines to print.
-   If OUT is zero, do not actually print anything; just scan the format.  */
-
-static char const *
-format_group (register FILE *out, char const *format, char endchar,
-	      struct group const *groups)
-{
-  register char c;
-  register char const *f = format;
-
-  while ((c = *f) != endchar && c != 0)
-    {
-      char const *f1 = ++f;
-      if (c == '%')
-	switch ((c = *f++))
-	  {
-	  case '%':
-	    break;
-
-	  case '(':
-	    /* Print if-then-else format e.g. `%(n=1?thenpart:elsepart)'.  */
-	    {
-	      int i;
-	      uintmax_t value[2];
-	      FILE *thenout, *elseout;
-
-	      for (i = 0; i < 2; i++)
-		{
-		  if (ISDIGIT (*f))
-		    {
-		      char *fend;
-		      errno = 0;
-		      value[i] = strtoumax (f, &fend, 10);
-		      if (errno)
-			goto bad_format;
-		      f = fend;
-		    }
-		  else
-		    {
-		      value[i] = groups_letter_value (groups, *f);
-		      if (value[i] == -1)
-			goto bad_format;
-		      f++;
-		    }
-		  if (*f++ != "=?"[i])
-		    goto bad_format;
-		}
-	      if (value[0] == value[1])
-		thenout = out, elseout = 0;
-	      else
-		thenout = 0, elseout = out;
-	      f = format_group (thenout, f, ':', groups);
-	      if (*f)
-		{
-		  f = format_group (elseout, f + 1, ')', groups);
-		  if (*f)
-		    f++;
-		}
-	    }
-	    continue;
-
-	  case '<':
-	    /* Print lines deleted from first file.  */
-	    print_ifdef_lines (out, line_format[OLD], &groups[0]);
-	    continue;
-
-	  case '=':
-	    /* Print common lines.  */
-	    print_ifdef_lines (out, line_format[UNCHANGED], &groups[0]);
-	    continue;
-
-	  case '>':
-	    /* Print lines inserted from second file.  */
-	    print_ifdef_lines (out, line_format[NEW], &groups[1]);
-	    continue;
-
-	  default:
-	    f = do_printf_spec (out, f - 2, 0, 0, groups);
-	    if (f)
-	      continue;
-	    /* Fall through. */
-	  bad_format:
-	    c = '%';
-	    f = f1;
-	    break;
-	  }
-
-      if (out)
-	putc (c, out);
-    }
-
-  return f;
-}
-
-/* For the line group pair G, return the number corresponding to LETTER.
-   Return -1 if LETTER is not a group format letter.  */
-static lin
-groups_letter_value (struct group const *g, char letter)
-{
-  switch (letter)
-    {
-    case 'E': letter = 'e'; g++; break;
-    case 'F': letter = 'f'; g++; break;
-    case 'L': letter = 'l'; g++; break;
-    case 'M': letter = 'm'; g++; break;
-    case 'N': letter = 'n'; g++; break;
-    }
-
-  switch (letter)
-    {
-      case 'e': return translate_line_number (g->file, g->from) - 1;
-      case 'f': return translate_line_number (g->file, g->from);
-      case 'l': return translate_line_number (g->file, g->upto) - 1;
-      case 'm': return translate_line_number (g->file, g->upto);
-      case 'n': return g->upto - g->from;
-      default: return -1;
-    }
-}
-
-/* Print to file OUT, using FORMAT to print the line group GROUP.
-   But do nothing if OUT is zero.  */
-static void
-print_ifdef_lines (register FILE *out, char const *format,
-		   struct group const *group)
-{
-  struct file_data const *file = group->file;
-  char const * const *linbuf = file->linbuf;
-  lin from = group->from, upto = group->upto;
-
-  if (!out)
-    return;
-
-  /* If possible, use a single fwrite; it's faster.  */
-  if (!expand_tabs && format[0] == '%')
-    {
-      if (format[1] == 'l' && format[2] == '\n' && !format[3] && from < upto)
-	{
-	  fwrite (linbuf[from], sizeof (char),
-		  linbuf[upto] + (linbuf[upto][-1] != '\n') -  linbuf[from],
-		  out);
-	  return;
-	}
-      if (format[1] == 'L' && !format[2])
-	{
-	  fwrite (linbuf[from], sizeof (char),
-		  linbuf[upto] -  linbuf[from], out);
-	  return;
-	}
-    }
-
-  for (;  from < upto;  from++)
-    {
-      register char c;
-      register char const *f = format;
-
-      while ((c = *f++) != 0)
-	{
-	  char const *f1 = f;
-	  if (c == '%')
-	    switch ((c = *f++))
-	      {
-	      case '%':
-		break;
-
-	      case 'l':
-		output_1_line (linbuf[from],
-			       (linbuf[from + 1]
-				- (linbuf[from + 1][-1] == '\n')),
-			       0, 0);
-		continue;
-
-	      case 'L':
-		output_1_line (linbuf[from], linbuf[from + 1], 0, 0);
-		continue;
-
-	      default:
-		f = do_printf_spec (out, f - 2, file, from, 0);
-		if (f)
-		  continue;
-		c = '%';
-		f = f1;
-		break;
-	      }
-
-	  putc (c, out);
-	}
-    }
-}
-
-static char const *
-do_printf_spec (FILE *out, char const *spec,
-		struct file_data const *file, lin n,
-		struct group const *groups)
-{
-  char const *f = spec;
-  char c;
-  char c1;
-
-  /* Scan printf-style SPEC of the form %[-'0]*[0-9]*(.[0-9]*)?[cdoxX].  */
-  /* assert (*f == '%'); */
-  f++;
-  while ((c = *f++) == '-' || c == '\'' || c == '0')
-    continue;
-  while (ISDIGIT (c))
-    c = *f++;
-  if (c == '.')
-    while (ISDIGIT (c = *f++))
-      continue;
-  c1 = *f++;
-
-  switch (c)
-    {
-    case 'c':
-      if (c1 != '\'')
-	return 0;
-      else
-	{
-	  char value IF_LINT (= 0);
-	  f = scan_char_literal (f, &value);
-	  if (!f)
-	    return 0;
-	  if (out)
-	    putc (value, out);
-	}
-      break;
-
-    case 'd': case 'o': case 'x': case 'X':
-      {
-	lin value;
-
-	if (file)
-	  {
-	    if (c1 != 'n')
-	      return 0;
-	    value = translate_line_number (file, n);
-	  }
-	else
-	  {
-	    value = groups_letter_value (groups, c1);
-	    if (value < 0)
-	      return 0;
-	  }
-
-	if (out)
-	  {
-	    /* For example, if the spec is "%3xn", use the printf
-	       format spec "%3lx".  Here the spec prefix is "%3".  */
-	    long int long_value = value;
-	    size_t spec_prefix_len = f - spec - 2;
-#if HAVE_C_VARARRAYS
-	    char format[spec_prefix_len + 3];
-#else
-	    char *format = xmalloc (spec_prefix_len + 3);
-#endif
-	    char *p = format + spec_prefix_len;
-	    memcpy (format, spec, spec_prefix_len);
-	    *p++ = 'l';
-	    *p++ = c;
-	    *p = '\0';
-	    fprintf (out, format, long_value);
-#if ! HAVE_C_VARARRAYS
-	    free (format);
-#endif
-	  }
-      }
-      break;
-
-    default:
-      return 0;
-    }
-
-  return f;
-}
-
-/* Scan the character literal represented in the string LIT; LIT points just
-   after the initial apostrophe.  Put the literal's value into *VALPTR.
-   Yield the address of the first character after the closing apostrophe,
-   or a null pointer if the literal is ill-formed.  */
-static char const *
-scan_char_literal (char const *lit, char *valptr)
-{
-  register char const *p = lit;
-  char value;
-  ptrdiff_t digits;
-  char c = *p++;
-
-  switch (c)
-    {
-      case 0:
-      case '\'':
-	return NULL;
-
-      case '\\':
-	value = 0;
-	while ((c = *p++) != '\'')
-	  {
-	    unsigned int digit = c - '0';
-	    if (8 <= digit)
-	      return NULL;
-	    value = 8 * value + digit;
-	  }
-	digits = p - lit - 2;
-	if (! (1 <= digits && digits <= 3))
-	  return NULL;
-	break;
-
-      default:
-	value = c;
-	if (*p++ != '\'')
-	  return NULL;
-	break;
-    }
-
-  *valptr = value;
-  return p;
-}
diff --git a/src/io.c b/src/io.c
deleted file mode 100644
index 031be3d..0000000
--- a/src/io.c
+++ /dev/null
@@ -1,845 +0,0 @@
-/* File I/O for GNU DIFF.
-
-   Copyright (C) 1988-1989, 1992-1995, 1998, 2001-2002, 2004, 2006, 2009-2010
-   Free Software Foundation, Inc.
-
-   This file is part of GNU DIFF.
-
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-#include "diff.h"
-#include <cmpbuf.h>
-#include <file-type.h>
-#include <xalloc.h>
-
-/* Rotate an unsigned value to the left.  */
-#define ROL(v, n) ((v) << (n) | (v) >> (sizeof (v) * CHAR_BIT - (n)))
-
-/* Given a hash value and a new character, return a new hash value.  */
-#define HASH(h, c) ((c) + ROL (h, 7))
-
-/* The type of a hash value.  */
-typedef size_t hash_value;
-verify (! TYPE_SIGNED (hash_value));
-
-/* Lines are put into equivalence classes of lines that match in lines_differ.
-   Each equivalence class is represented by one of these structures,
-   but only while the classes are being computed.
-   Afterward, each class is represented by a number.  */
-struct equivclass
-{
-  lin next;		/* Next item in this bucket.  */
-  hash_value hash;	/* Hash of lines in this class.  */
-  char const *line;	/* A line that fits this class.  */
-  size_t length;	/* That line's length, not counting its newline.  */
-};
-
-/* Hash-table: array of buckets, each being a chain of equivalence classes.
-   buckets[-1] is reserved for incomplete lines.  */
-static lin *buckets;
-
-/* Number of buckets in the hash table array, not counting buckets[-1].  */
-static size_t nbuckets;
-
-/* Array in which the equivalence classes are allocated.
-   The bucket-chains go through the elements in this array.
-   The number of an equivalence class is its index in this array.  */
-static struct equivclass *equivs;
-
-/* Index of first free element in the array `equivs'.  */
-static lin equivs_index;
-
-/* Number of elements allocated in the array `equivs'.  */
-static lin equivs_alloc;
-
-/* Read a block of data into a file buffer, checking for EOF and error.  */
-
-void
-file_block_read (struct file_data *current, size_t size)
-{
-  if (size && ! current->eof)
-    {
-      size_t s = block_read (current->desc,
-			     FILE_BUFFER (current) + current->buffered, size);
-      if (s == SIZE_MAX)
-	pfatal_with_name (current->name);
-      current->buffered += s;
-      current->eof = s < size;
-    }
-}
-
-/* Check for binary files and compare them for exact identity.  */
-
-/* Return 1 if BUF contains a non text character.
-   SIZE is the number of characters in BUF.  */
-
-#define binary_file_p(buf, size) (memchr (buf, 0, size) != 0)
-
-/* Get ready to read the current file.
-   Return nonzero if SKIP_TEST is zero,
-   and if it appears to be a binary file.  */
-
-static bool
-sip (struct file_data *current, bool skip_test)
-{
-  /* If we have a nonexistent file at this stage, treat it as empty.  */
-  if (current->desc < 0)
-    {
-      /* Leave room for a sentinel.  */
-      current->bufsize = sizeof (word);
-      current->buffer = xmalloc (current->bufsize);
-    }
-  else
-    {
-      current->bufsize = buffer_lcm (sizeof (word),
-				     STAT_BLOCKSIZE (current->stat),
-				     PTRDIFF_MAX - 2 * sizeof (word));
-      current->buffer = xmalloc (current->bufsize);
-
-      if (! skip_test)
-	{
-	  /* Check first part of file to see if it's a binary file.  */
-
-	  /* FIXME: if O_BINARY, this should revert to text mode
-	     if the file is not binary.  */
-
-	  file_block_read (current, current->bufsize);
-	  return binary_file_p (current->buffer, current->buffered);
-	}
-    }
-
-  current->buffered = 0;
-  current->eof = false;
-  return false;
-}
-
-/* Slurp the rest of the current file completely into memory.  */
-
-static void
-slurp (struct file_data *current)
-{
-  size_t cc;
-
-  if (current->desc < 0)
-    {
-      /* The file is nonexistent.  */
-      return;
-    }
-
-  if (S_ISREG (current->stat.st_mode))
-    {
-      /* It's a regular file; slurp in the rest all at once.  */
-
-      /* Get the size out of the stat block.
-	 Allocate just enough room for appended newline plus word sentinel,
-	 plus word-alignment since we want the buffer word-aligned.  */
-      size_t file_size = current->stat.st_size;
-      cc = file_size + 2 * sizeof (word) - file_size % sizeof (word);
-      if (file_size != current->stat.st_size || cc < file_size
-	  || PTRDIFF_MAX <= cc)
-	xalloc_die ();
-
-      if (current->bufsize < cc)
-	{
-	  current->bufsize = cc;
-	  current->buffer = xrealloc (current->buffer, cc);
-	}
-
-      /* Try to read at least 1 more byte than the size indicates, to
-	 detect whether the file is growing.  This is a nicety for
-	 users who run 'diff' on files while they are changing.  */
-
-      if (current->buffered <= file_size)
-	{
-	  file_block_read (current, file_size + 1 - current->buffered);
-	  if (current->buffered <= file_size)
-	    return;
-	}
-    }
-
-  /* It's not a regular file, or it's a growing regular file; read it,
-     growing the buffer as needed.  */
-
-  file_block_read (current, current->bufsize - current->buffered);
-
-  if (current->buffered)
-    {
-      while (current->buffered == current->bufsize)
-	{
-	  if (PTRDIFF_MAX / 2 - sizeof (word) < current->bufsize)
-	    xalloc_die ();
-	  current->bufsize *= 2;
-	  current->buffer = xrealloc (current->buffer, current->bufsize);
-	  file_block_read (current, current->bufsize - current->buffered);
-	}
-
-      /* Allocate just enough room for appended newline plus word
-	 sentinel, plus word-alignment.  */
-      cc = current->buffered + 2 * sizeof (word);
-      current->bufsize = cc - cc % sizeof (word);
-      current->buffer = xrealloc (current->buffer, current->bufsize);
-    }
-}
-
-/* Split the file into lines, simultaneously computing the equivalence
-   class for each line.  */
-
-static void
-find_and_hash_each_line (struct file_data *current)
-{
-  hash_value h;
-  char const *p = current->prefix_end;
-  unsigned char c;
-  lin i, *bucket;
-  size_t length;
-
-  /* Cache often-used quantities in local variables to help the compiler.  */
-  char const **linbuf = current->linbuf;
-  lin alloc_lines = current->alloc_lines;
-  lin line = 0;
-  lin linbuf_base = current->linbuf_base;
-  lin *cureqs = xmalloc (alloc_lines * sizeof *cureqs);
-  struct equivclass *eqs = equivs;
-  lin eqs_index = equivs_index;
-  lin eqs_alloc = equivs_alloc;
-  char const *suffix_begin = current->suffix_begin;
-  char const *bufend = FILE_BUFFER (current) + current->buffered;
-  bool diff_length_compare_anyway =
-    ignore_white_space != IGNORE_NO_WHITE_SPACE;
-  bool same_length_diff_contents_compare_anyway =
-    diff_length_compare_anyway | ignore_case;
-
-  while (p < suffix_begin)
-    {
-      char const *ip = p;
-
-      h = 0;
-
-      /* Hash this line until we find a newline.  */
-      if (ignore_case)
-	switch (ignore_white_space)
-	  {
-	  case IGNORE_ALL_SPACE:
-	    while ((c = *p++) != '\n')
-	      if (! isspace (c))
-		h = HASH (h, tolower (c));
-	    break;
-
-	  case IGNORE_SPACE_CHANGE:
-	    while ((c = *p++) != '\n')
-	      {
-		if (isspace (c))
-		  {
-		    do
-		      if ((c = *p++) == '\n')
-			goto hashing_done;
-		    while (isspace (c));
-
-		    h = HASH (h, ' ');
-		  }
-
-		/* C is now the first non-space.  */
-		h = HASH (h, tolower (c));
-	      }
-	    break;
-
-	  case IGNORE_TAB_EXPANSION:
-	    {
-	      size_t column = 0;
-	      while ((c = *p++) != '\n')
-		{
-		  size_t repetitions = 1;
-
-		  switch (c)
-		    {
-		    case '\b':
-		      column -= 0 < column;
-		      break;
-
-		    case '\t':
-		      c = ' ';
-		      repetitions = tabsize - column % tabsize;
-		      column = (column + repetitions < column
-				? 0
-				: column + repetitions);
-		      break;
-
-		    case '\r':
-		      column = 0;
-		      break;
-
-		    default:
-		      c = tolower (c);
-		      column++;
-		      break;
-		    }
-
-		  do
-		    h = HASH (h, c);
-		  while (--repetitions != 0);
-		}
-	    }
-	    break;
-
-	  default:
-	    while ((c = *p++) != '\n')
-	      h = HASH (h, tolower (c));
-	    break;
-	  }
-      else
-	switch (ignore_white_space)
-	  {
-	  case IGNORE_ALL_SPACE:
-	    while ((c = *p++) != '\n')
-	      if (! isspace (c))
-		h = HASH (h, c);
-	    break;
-
-	  case IGNORE_SPACE_CHANGE:
-	    while ((c = *p++) != '\n')
-	      {
-		if (isspace (c))
-		  {
-		    do
-		      if ((c = *p++) == '\n')
-			goto hashing_done;
-		    while (isspace (c));
-
-		    h = HASH (h, ' ');
-		  }
-
-		/* C is now the first non-space.  */
-		h = HASH (h, c);
-	      }
-	    break;
-
-	  case IGNORE_TAB_EXPANSION:
-	    {
-	      size_t column = 0;
-	      while ((c = *p++) != '\n')
-		{
-		  size_t repetitions = 1;
-
-		  switch (c)
-		    {
-		    case '\b':
-		      column -= 0 < column;
-		      break;
-
-		    case '\t':
-		      c = ' ';
-		      repetitions = tabsize - column % tabsize;
-		      column = (column + repetitions < column
-				? 0
-				: column + repetitions);
-		      break;
-
-		    case '\r':
-		      column = 0;
-		      break;
-
-		    default:
-		      column++;
-		      break;
-		    }
-
-		  do
-		    h = HASH (h, c);
-		  while (--repetitions != 0);
-		}
-	    }
-	    break;
-
-	  default:
-	    while ((c = *p++) != '\n')
-	      h = HASH (h, c);
-	    break;
-	  }
-
-   hashing_done:;
-
-      bucket = &buckets[h % nbuckets];
-      length = p - ip - 1;
-
-      if (p == bufend
-	  && current->missing_newline
-	  && ROBUST_OUTPUT_STYLE (output_style))
-	{
-	  /* The last line is incomplete and we do not silently
-	     complete lines.  If the line cannot compare equal to any
-	     complete line, put it into buckets[-1] so that it can
-	     compare equal only to the other file's incomplete line
-	     (if one exists).  */
-	  if (ignore_white_space < IGNORE_SPACE_CHANGE)
-	    bucket = &buckets[-1];
-	}
-
-      for (i = *bucket;  ;  i = eqs[i].next)
-	if (!i)
-	  {
-	    /* Create a new equivalence class in this bucket.  */
-	    i = eqs_index++;
-	    if (i == eqs_alloc)
-	      {
-		if (PTRDIFF_MAX / (2 * sizeof *eqs) <= eqs_alloc)
-		  xalloc_die ();
-		eqs_alloc *= 2;
-		eqs = xrealloc (eqs, eqs_alloc * sizeof *eqs);
-	      }
-	    eqs[i].next = *bucket;
-	    eqs[i].hash = h;
-	    eqs[i].line = ip;
-	    eqs[i].length = length;
-	    *bucket = i;
-	    break;
-	  }
-	else if (eqs[i].hash == h)
-	  {
-	    char const *eqline = eqs[i].line;
-
-	    /* Reuse existing class if lines_differ reports the lines
-               equal.  */
-	    if (eqs[i].length == length)
-	      {
-		/* Reuse existing equivalence class if the lines are identical.
-		   This detects the common case of exact identity
-		   faster than lines_differ would.  */
-		if (memcmp (eqline, ip, length) == 0)
-		  break;
-		if (!same_length_diff_contents_compare_anyway)
-		  continue;
-	      }
-	    else if (!diff_length_compare_anyway)
-	      continue;
-
-	    if (! lines_differ (eqline, ip))
-	      break;
-	  }
-
-      /* Maybe increase the size of the line table.  */
-      if (line == alloc_lines)
-	{
-	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
-	  if (PTRDIFF_MAX / 3 <= alloc_lines
-	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
-	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
-	    xalloc_die ();
-	  alloc_lines = 2 * alloc_lines - linbuf_base;
-	  cureqs = xrealloc (cureqs, alloc_lines * sizeof *cureqs);
-	  linbuf += linbuf_base;
-	  linbuf = xrealloc (linbuf,
-			     (alloc_lines - linbuf_base) * sizeof *linbuf);
-	  linbuf -= linbuf_base;
-	}
-      linbuf[line] = ip;
-      cureqs[line] = i;
-      ++line;
-    }
-
-  current->buffered_lines = line;
-
-  for (i = 0;  ;  i++)
-    {
-      /* Record the line start for lines in the suffix that we care about.
-	 Record one more line start than lines,
-	 so that we can compute the length of any buffered line.  */
-      if (line == alloc_lines)
-	{
-	  /* Double (alloc_lines - linbuf_base) by adding to alloc_lines.  */
-	  if (PTRDIFF_MAX / 3 <= alloc_lines
-	      || PTRDIFF_MAX / sizeof *cureqs <= 2 * alloc_lines - linbuf_base
-	      || PTRDIFF_MAX / sizeof *linbuf <= alloc_lines - linbuf_base)
-	    xalloc_die ();
-	  alloc_lines = 2 * alloc_lines - linbuf_base;
-	  linbuf += linbuf_base;
-	  linbuf = xrealloc (linbuf,
-			     (alloc_lines - linbuf_base) * sizeof *linbuf);
-	  linbuf -= linbuf_base;
-	}
-      linbuf[line] = p;
-
-      if (p == bufend)
-	{
-	  /* If the last line is incomplete and we do not silently
-	     complete lines, don't count its appended newline.  */
-	  if (current->missing_newline && ROBUST_OUTPUT_STYLE (output_style))
-	    linbuf[line]--;
-	  break;
-	}
-
-      if (context <= i && no_diff_means_no_output)
-	break;
-
-      line++;
-
-      while (*p++ != '\n')
-	continue;
-    }
-
-  /* Done with cache in local variables.  */
-  current->linbuf = linbuf;
-  current->valid_lines = line;
-  current->alloc_lines = alloc_lines;
-  current->equivs = cureqs;
-  equivs = eqs;
-  equivs_alloc = eqs_alloc;
-  equivs_index = eqs_index;
-}
-
-/* Prepare the text.  Make sure the text end is initialized.
-   Make sure text ends in a newline,
-   but remember that we had to add one.
-   Strip trailing CRs, if that was requested.  */
-
-static void
-prepare_text (struct file_data *current)
-{
-  size_t buffered = current->buffered;
-  char *p = FILE_BUFFER (current);
-  char *dst;
-
-  if (buffered == 0 || p[buffered - 1] == '\n')
-    current->missing_newline = false;
-  else
-    {
-      p[buffered++] = '\n';
-      current->missing_newline = true;
-    }
-
-  if (!p)
-    return;
-
-  /* Don't use uninitialized storage when planting or using sentinels.  */
-  memset (p + buffered, 0, sizeof (word));
-
-  if (strip_trailing_cr && (dst = memchr (p, '\r', buffered)))
-    {
-      char const *src = dst;
-      char const *srclim = p + buffered;
-
-      do
-	dst += ! ((*dst = *src++) == '\r' && *src == '\n');
-      while (src < srclim);
-
-      buffered -= src - dst;
-    }
-
-  current->buffered = buffered;
-}
-
-/* We have found N lines in a buffer of size S; guess the
-   proportionate number of lines that will be found in a buffer of
-   size T.  However, do not guess a number of lines so large that the
-   resulting line table might cause overflow in size calculations.  */
-static lin
-guess_lines (lin n, size_t s, size_t t)
-{
-  size_t guessed_bytes_per_line = n < 10 ? 32 : s / (n - 1);
-  lin guessed_lines = MAX (1, t / guessed_bytes_per_line);
-  return MIN (guessed_lines, PTRDIFF_MAX / (2 * sizeof (char *) + 1) - 5) + 5;
-}
-
-/* Given a vector of two file_data objects, find the identical
-   prefixes and suffixes of each object.  */
-
-static void
-find_identical_ends (struct file_data filevec[])
-{
-  word *w0, *w1;
-  char *p0, *p1, *buffer0, *buffer1;
-  char const *end0, *beg0;
-  char const **linbuf0, **linbuf1;
-  lin i, lines;
-  size_t n0, n1;
-  lin alloc_lines0, alloc_lines1;
-  lin buffered_prefix, prefix_count, prefix_mask;
-  lin middle_guess, suffix_guess;
-
-  slurp (&filevec[0]);
-  prepare_text (&filevec[0]);
-  if (filevec[0].desc != filevec[1].desc)
-    {
-      slurp (&filevec[1]);
-      prepare_text (&filevec[1]);
-    }
-  else
-    {
-      filevec[1].buffer = filevec[0].buffer;
-      filevec[1].bufsize = filevec[0].bufsize;
-      filevec[1].buffered = filevec[0].buffered;
-      filevec[1].missing_newline = filevec[0].missing_newline;
-    }
-
-  /* Find identical prefix.  */
-
-  w0 = filevec[0].buffer;
-  w1 = filevec[1].buffer;
-  p0 = buffer0 = (char *) w0;
-  p1 = buffer1 = (char *) w1;
-  n0 = filevec[0].buffered;
-  n1 = filevec[1].buffered;
-
-  if (p0 == p1)
-    /* The buffers are the same; sentinels won't work.  */
-    p0 = p1 += n1;
-  else
-    {
-      /* Insert end sentinels, in this case characters that are guaranteed
-	 to make the equality test false, and thus terminate the loop.  */
-
-      if (n0 < n1)
-	p0[n0] = ~p1[n0];
-      else
-	p1[n1] = ~p0[n1];
-
-      /* Loop until first mismatch, or to the sentinel characters.  */
-
-      /* Compare a word at a time for speed.  */
-      while (*w0 == *w1)
-	w0++, w1++;
-
-      /* Do the last few bytes of comparison a byte at a time.  */
-      p0 = (char *) w0;
-      p1 = (char *) w1;
-      while (*p0 == *p1)
-	p0++, p1++;
-
-      /* Don't mistakenly count missing newline as part of prefix.  */
-      if (ROBUST_OUTPUT_STYLE (output_style)
-	  && ((buffer0 + n0 - filevec[0].missing_newline < p0)
-	      !=
-	      (buffer1 + n1 - filevec[1].missing_newline < p1)))
-	p0--, p1--;
-    }
-
-  /* Now P0 and P1 point at the first nonmatching characters.  */
-
-  /* Skip back to last line-beginning in the prefix,
-     and then discard up to HORIZON_LINES lines from the prefix.  */
-  i = horizon_lines;
-  while (p0 != buffer0 && (p0[-1] != '\n' || i--))
-    p0--, p1--;
-
-  /* Record the prefix.  */
-  filevec[0].prefix_end = p0;
-  filevec[1].prefix_end = p1;
-
-  /* Find identical suffix.  */
-
-  /* P0 and P1 point beyond the last chars not yet compared.  */
-  p0 = buffer0 + n0;
-  p1 = buffer1 + n1;
-
-  if (! ROBUST_OUTPUT_STYLE (output_style)
-      || filevec[0].missing_newline == filevec[1].missing_newline)
-    {
-      end0 = p0;	/* Addr of last char in file 0.  */
-
-      /* Get value of P0 at which we should stop scanning backward:
-	 this is when either P0 or P1 points just past the last char
-	 of the identical prefix.  */
-      beg0 = filevec[0].prefix_end + (n0 < n1 ? 0 : n0 - n1);
-
-      /* Scan back until chars don't match or we reach that point.  */
-      while (p0 != beg0)
-	if (*--p0 != *--p1)
-	  {
-	    /* Point at the first char of the matching suffix.  */
-	    ++p0, ++p1;
-	    beg0 = p0;
-	    break;
-	  }
-
-      /* Are we at a line-beginning in both files?  If not, add the rest of
-	 this line to the main body.  Discard up to HORIZON_LINES lines from
-	 the identical suffix.  Also, discard one extra line,
-	 because shift_boundaries may need it.  */
-      i = horizon_lines + !((buffer0 == p0 || p0[-1] == '\n')
-			    &&
-			    (buffer1 == p1 || p1[-1] == '\n'));
-      while (i-- && p0 != end0)
-	while (*p0++ != '\n')
-	  continue;
-
-      p1 += p0 - beg0;
-    }
-
-  /* Record the suffix.  */
-  filevec[0].suffix_begin = p0;
-  filevec[1].suffix_begin = p1;
-
-  /* Calculate number of lines of prefix to save.
-
-     prefix_count == 0 means save the whole prefix;
-     we need this for options like -D that output the whole file,
-     or for enormous contexts (to avoid worrying about arithmetic overflow).
-     We also need it for options like -F that output some preceding line;
-     at least we will need to find the last few lines,
-     but since we don't know how many, it's easiest to find them all.
-
-     Otherwise, prefix_count != 0.  Save just prefix_count lines at start
-     of the line buffer; they'll be moved to the proper location later.
-     Handle 1 more line than the context says (because we count 1 too many),
-     rounded up to the next power of 2 to speed index computation.  */
-
-  if (no_diff_means_no_output && ! function_regexp.fastmap
-      && context < LIN_MAX / 4 && context < n0)
-    {
-      middle_guess = guess_lines (0, 0, p0 - filevec[0].prefix_end);
-      suffix_guess = guess_lines (0, 0, buffer0 + n0 - p0);
-      for (prefix_count = 1;  prefix_count <= context;  prefix_count *= 2)
-	continue;
-      alloc_lines0 = (prefix_count + middle_guess
-		      + MIN (context, suffix_guess));
-    }
-  else
-    {
-      prefix_count = 0;
-      alloc_lines0 = guess_lines (0, 0, n0);
-    }
-
-  prefix_mask = prefix_count - 1;
-  lines = 0;
-  linbuf0 = xmalloc (alloc_lines0 * sizeof *linbuf0);
-  p0 = buffer0;
-
-  /* If the prefix is needed, find the prefix lines.  */
-  if (! (no_diff_means_no_output
-	 && filevec[0].prefix_end == p0
-	 && filevec[1].prefix_end == p1))
-    {
-      end0 = filevec[0].prefix_end;
-      while (p0 != end0)
-	{
-	  lin l = lines++ & prefix_mask;
-	  if (l == alloc_lines0)
-	    {
-	      if (PTRDIFF_MAX / (2 * sizeof *linbuf0) <= alloc_lines0)
-		xalloc_die ();
-	      alloc_lines0 *= 2;
-	      linbuf0 = xrealloc (linbuf0, alloc_lines0 * sizeof *linbuf0);
-	    }
-	  linbuf0[l] = p0;
-	  while (*p0++ != '\n')
-	    continue;
-	}
-    }
-  buffered_prefix = prefix_count && context < lines ? context : lines;
-
-  /* Allocate line buffer 1.  */
-
-  middle_guess = guess_lines (lines, p0 - buffer0, p1 - filevec[1].prefix_end);
-  suffix_guess = guess_lines (lines, p0 - buffer0, buffer1 + n1 - p1);
-  alloc_lines1 = buffered_prefix + middle_guess + MIN (context, suffix_guess);
-  if (alloc_lines1 < buffered_prefix
-      || PTRDIFF_MAX / sizeof *linbuf1 <= alloc_lines1)
-    xalloc_die ();
-  linbuf1 = xmalloc (alloc_lines1 * sizeof *linbuf1);
-
-  if (buffered_prefix != lines)
-    {
-      /* Rotate prefix lines to proper location.  */
-      for (i = 0;  i < buffered_prefix;  i++)
-	linbuf1[i] = linbuf0[(lines - context + i) & prefix_mask];
-      for (i = 0;  i < buffered_prefix;  i++)
-	linbuf0[i] = linbuf1[i];
-    }
-
-  /* Initialize line buffer 1 from line buffer 0.  */
-  for (i = 0; i < buffered_prefix; i++)
-    linbuf1[i] = linbuf0[i] - buffer0 + buffer1;
-
-  /* Record the line buffer, adjusted so that
-     linbuf[0] points at the first differing line.  */
-  filevec[0].linbuf = linbuf0 + buffered_prefix;
-  filevec[1].linbuf = linbuf1 + buffered_prefix;
-  filevec[0].linbuf_base = filevec[1].linbuf_base = - buffered_prefix;
-  filevec[0].alloc_lines = alloc_lines0 - buffered_prefix;
-  filevec[1].alloc_lines = alloc_lines1 - buffered_prefix;
-  filevec[0].prefix_lines = filevec[1].prefix_lines = lines;
-}
-
-/* If 1 < k, then (2**k - prime_offset[k]) is the largest prime less
-   than 2**k.  This table is derived from Chris K. Caldwell's list
-   <http://www.utm.edu/research/primes/lists/2small/>.  */
-
-static unsigned char const prime_offset[] =
-{
-  0, 0, 1, 1, 3, 1, 3, 1, 5, 3, 3, 9, 3, 1, 3, 19, 15, 1, 5, 1, 3, 9, 3,
-  15, 3, 39, 5, 39, 57, 3, 35, 1, 5, 9, 41, 31, 5, 25, 45, 7, 87, 21,
-  11, 57, 17, 55, 21, 115, 59, 81, 27, 129, 47, 111, 33, 55, 5, 13, 27,
-  55, 93, 1, 57, 25
-};
-
-/* Verify that this host's size_t is not too wide for the above table.  */
-
-verify (sizeof (size_t) * CHAR_BIT <= sizeof prime_offset);
-
-/* Given a vector of two file_data objects, read the file associated
-   with each one, and build the table of equivalence classes.
-   Return nonzero if either file appears to be a binary file.
-   If PRETEND_BINARY is nonzero, pretend they are binary regardless.  */
-
-bool
-read_files (struct file_data filevec[], bool pretend_binary)
-{
-  int i;
-  bool skip_test = text | pretend_binary;
-  bool appears_binary = pretend_binary | sip (&filevec[0], skip_test);
-
-  if (filevec[0].desc != filevec[1].desc)
-    appears_binary |= sip (&filevec[1], skip_test | appears_binary);
-  else
-    {
-      filevec[1].buffer = filevec[0].buffer;
-      filevec[1].bufsize = filevec[0].bufsize;
-      filevec[1].buffered = filevec[0].buffered;
-    }
-  if (appears_binary)
-    {
-      /* FIXME: If O_BINARY, this should set both files to binary mode.  */
-      return true;
-    }
-
-  find_identical_ends (filevec);
-
-  equivs_alloc = filevec[0].alloc_lines + filevec[1].alloc_lines + 1;
-  if (PTRDIFF_MAX / sizeof *equivs <= equivs_alloc)
-    xalloc_die ();
-  equivs = xmalloc (equivs_alloc * sizeof *equivs);
-  /* Equivalence class 0 is permanently safe for lines that were not
-     hashed.  Real equivalence classes start at 1.  */
-  equivs_index = 1;
-
-  /* Allocate (one plus) a prime number of hash buckets.  Use a prime
-     number between 1/3 and 2/3 of the value of equiv_allocs,
-     approximately.  */
-  for (i = 9; (size_t) 1 << i < equivs_alloc / 3; i++)
-    continue;
-  nbuckets = ((size_t) 1 << i) - prime_offset[i];
-  if (PTRDIFF_MAX / sizeof *buckets <= nbuckets)
-    xalloc_die ();
-  buckets = zalloc ((nbuckets + 1) * sizeof *buckets);
-  buckets++;
-
-  for (i = 0; i < 2; i++)
-    find_and_hash_each_line (&filevec[i]);
-
-  filevec[0].equiv_max = filevec[1].equiv_max = equivs_index;
-
-  free (equivs);
-  free (buckets - 1);
-
-  return false;
-}
diff --git a/src/sdiff.c b/src/sdiff.c
index 4344e8d..df2796c 100644
--- a/src/sdiff.c
+++ b/src/sdiff.c
@@ -35,7 +35,7 @@
 #include <version-etc.h>
 #include <xalloc.h>
 
-/* The official name of this program (e.g., no `g' prefix).  */
+/* The official name of this program (e.g., no 'g' prefix).  */
 #define PROGRAM_NAME "sdiff"
 
 #define AUTHORS \
@@ -92,7 +92,7 @@ static int const sigs[] = {
 };
 
 #if HAVE_SIGACTION
-  /* Prefer `sigaction' if available, since `signal' can lose signals.  */
+  /* Prefer 'sigaction' if available, since 'signal' can lose signals.  */
   static struct sigaction initial_action[NUM_SIGS];
 # define initial_handler(i) (initial_action[i].sa_handler)
   static void signal_handler (int, void (*) (int));
@@ -230,7 +230,7 @@ usage (void)
     else
       putchar ('\n');
   printf ("\n%s\n%s\n",
-	  _("If a FILE is `-', read standard input."),
+	  _("If a FILE is '-', read standard input."),
 	  _("Exit status is 0 if inputs are the same, 1 if different, 2 if trouble."));
   emit_bug_reporting_address ();
 }
@@ -747,7 +747,7 @@ main (int argc, char *argv[])
 	exit (WEXITSTATUS (wstatus));
       }
     }
-  return EXIT_SUCCESS;			/* Fool `-Wall'.  */
+  return EXIT_SUCCESS;			/* Fool '-Wall'.  */
 }
 
 static void
diff --git a/src/side.c b/src/side.c
deleted file mode 100644
index 6aa96a9..0000000
--- a/src/side.c
+++ /dev/null
@@ -1,320 +0,0 @@
-/* sdiff-format output routines for GNU DIFF.
-
-   Copyright (C) 1991-1993, 1998, 2001-2002, 2004, 2009-2010 Free Software
-   Foundation, Inc.
-
-   This file is part of GNU DIFF.
-
-   GNU DIFF is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY.  No author or distributor
-   accepts responsibility to anyone for the consequences of using it
-   or for whether it serves any particular purpose or works at all,
-   unless he says so in writing.  Refer to the GNU General Public
-   License for full details.
-
-   Everyone is granted permission to copy, modify and redistribute
-   GNU DIFF, but only under the conditions described in the
-   GNU General Public License.   A copy of this license is
-   supposed to have been given to you along with GNU DIFF so you
-   can know your rights and responsibilities.  It should be in a
-   file named COPYING.  Among other things, the copyright notice
-   and this notice must be preserved on all copies.  */
-
-#include "diff.h"
-
-#include <wchar.h>
-
-static void print_sdiff_common_lines (lin, lin);
-static void print_sdiff_hunk (struct change *);
-
-/* Next line number to be printed in the two input files.  */
-static lin next0, next1;
-
-/* Print the edit-script SCRIPT as a sdiff style output.  */
-
-void
-print_sdiff_script (struct change *script)
-{
-  begin_output ();
-
-  next0 = next1 = - files[0].prefix_lines;
-  print_script (script, find_change, print_sdiff_hunk);
-
-  print_sdiff_common_lines (files[0].valid_lines, files[1].valid_lines);
-}
-
-/* Tab from column FROM to column TO, where FROM <= TO.  Yield TO.  */
-
-static size_t
-tab_from_to (size_t from, size_t to)
-{
-  FILE *out = outfile;
-  size_t tab;
-  size_t tab_size = tabsize;
-
-  if (!expand_tabs)
-    for (tab = from + tab_size - from % tab_size;  tab <= to;  tab += tab_size)
-      {
-	putc ('\t', out);
-	from = tab;
-      }
-  while (from++ < to)
-    putc (' ', out);
-  return to;
-}
-
-/* Print the text for half an sdiff line.  This means truncate to
-   width observing tabs, and trim a trailing newline.  Return the
-   last column written (not the number of chars).  */
-
-static size_t
-print_half_line (char const *const *line, size_t indent, size_t out_bound)
-{
-  FILE *out = outfile;
-  register size_t in_position = 0;
-  register size_t out_position = 0;
-  register char const *text_pointer = line[0];
-  register char const *text_limit = line[1];
-  mbstate_t mbstate = { 0 };
-
-  while (text_pointer < text_limit)
-    {
-      char const *tp0 = text_pointer;
-      register char c = *text_pointer++;
-
-      switch (c)
-	{
-	case '\t':
-	  {
-	    size_t spaces = tabsize - in_position % tabsize;
-	    if (in_position == out_position)
-	      {
-		size_t tabstop = out_position + spaces;
-		if (expand_tabs)
-		  {
-		    if (out_bound < tabstop)
-		      tabstop = out_bound;
-		    for (;  out_position < tabstop;  out_position++)
-		      putc (' ', out);
-		  }
-		else
-		  if (tabstop < out_bound)
-		    {
-		      out_position = tabstop;
-		      putc (c, out);
-		    }
-	      }
-	    in_position += spaces;
-	  }
-	  break;
-
-	case '\r':
-	  {
-	    putc (c, out);
-	    tab_from_to (0, indent);
-	    in_position = out_position = 0;
-	  }
-	  break;
-
-	case '\b':
-	  if (in_position != 0 && --in_position < out_bound)
-	    {
-	      if (out_position <= in_position)
-		/* Add spaces to make up for suppressed tab past out_bound.  */
-		for (;  out_position < in_position;  out_position++)
-		  putc (' ', out);
-	      else
-		{
-		  out_position = in_position;
-		  putc (c, out);
-		}
-	    }
-	  break;
-
-	default:
-	  {
-	    wchar_t wc;
-	    size_t bytes = mbrtowc (&wc, tp0, text_limit - tp0, &mbstate);
-
-	    if (0 < bytes && bytes < (size_t) -2)
-	      {
-		int width = wcwidth (wc);
-		if (0 < width)
-		  in_position += width;
-		if (in_position <= out_bound)
-		  {
-		    out_position = in_position;
-		    fwrite (tp0, 1, bytes, stdout);
-		  }
-		text_pointer = tp0 + bytes;
-		break;
-	      }
-	  }
-	  /* Fall through.  */
-	case '\f':
-	case '\v':
-	  if (in_position < out_bound)
-	    putc (c, out);
-	  break;
-
-	case ' ': case '!': case '"': case '#': case '%':
-	case '&': case '\'': case '(': case ')': case '*':
-	case '+': case ',': case '-': case '.': case '/':
-	case '0': case '1': case '2': case '3': case '4':
-	case '5': case '6': case '7': case '8': case '9':
-	case ':': case ';': case '<': case '=': case '>':
-	case '?':
-	case 'A': case 'B': case 'C': case 'D': case 'E':
-	case 'F': case 'G': case 'H': case 'I': case 'J':
-	case 'K': case 'L': case 'M': case 'N': case 'O':
-	case 'P': case 'Q': case 'R': case 'S': case 'T':
-	case 'U': case 'V': case 'W': case 'X': case 'Y':
-	case 'Z':
-	case '[': case '\\': case ']': case '^': case '_':
-	case 'a': case 'b': case 'c': case 'd': case 'e':
-	case 'f': case 'g': case 'h': case 'i': case 'j':
-	case 'k': case 'l': case 'm': case 'n': case 'o':
-	case 'p': case 'q': case 'r': case 's': case 't':
-	case 'u': case 'v': case 'w': case 'x': case 'y':
-	case 'z': case '{': case '|': case '}': case '~':
-	  /* These characters are printable ASCII characters.  */
-	  if (in_position++ < out_bound)
-	    {
-	      out_position = in_position;
-	      putc (c, out);
-	    }
-	  break;
-
-	case '\n':
-	  return out_position;
-	}
-    }
-
-  return out_position;
-}
-
-/* Print side by side lines with a separator in the middle.
-   0 parameters are taken to indicate white space text.
-   Blank lines that can easily be caught are reduced to a single newline.  */
-
-static void
-print_1sdiff_line (char const *const *left, char sep,
-		   char const *const *right)
-{
-  FILE *out = outfile;
-  size_t hw = sdiff_half_width;
-  size_t c2o = sdiff_column2_offset;
-  size_t col = 0;
-  bool put_newline = false;
-
-  if (left)
-    {
-      put_newline |= left[1][-1] == '\n';
-      col = print_half_line (left, 0, hw);
-    }
-
-  if (sep != ' ')
-    {
-      col = tab_from_to (col, (hw + c2o - 1) / 2) + 1;
-      if (sep == '|' && put_newline != (right[1][-1] == '\n'))
-	sep = put_newline ? '/' : '\\';
-      putc (sep, out);
-    }
-
-  if (right)
-    {
-      put_newline |= right[1][-1] == '\n';
-      if (**right != '\n')
-	{
-	  col = tab_from_to (col, c2o);
-	  print_half_line (right, col, hw);
-	}
-    }
-
-  if (put_newline)
-    putc ('\n', out);
-}
-
-/* Print lines common to both files in side-by-side format.  */
-static void
-print_sdiff_common_lines (lin limit0, lin limit1)
-{
-  lin i0 = next0, i1 = next1;
-
-  if (!suppress_common_lines && (i0 != limit0 || i1 != limit1))
-    {
-      if (sdiff_merge_assist)
-	{
-	  long int len0 = limit0 - i0;
-	  long int len1 = limit1 - i1;
-	  fprintf (outfile, "i%ld,%ld\n", len0, len1);
-	}
-
-      if (!left_column)
-	{
-	  while (i0 != limit0 && i1 != limit1)
-	    print_1sdiff_line (&files[0].linbuf[i0++], ' ',
-			       &files[1].linbuf[i1++]);
-	  while (i1 != limit1)
-	    print_1sdiff_line (0, ')', &files[1].linbuf[i1++]);
-	}
-      while (i0 != limit0)
-	print_1sdiff_line (&files[0].linbuf[i0++], '(', 0);
-    }
-
-  next0 = limit0;
-  next1 = limit1;
-}
-
-/* Print a hunk of an sdiff diff.
-   This is a contiguous portion of a complete edit script,
-   describing changes in consecutive lines.  */
-
-static void
-print_sdiff_hunk (struct change *hunk)
-{
-  lin first0, last0, first1, last1;
-  register lin i, j;
-
-  /* Determine range of line numbers involved in each file.  */
-  enum changes changes =
-    analyze_hunk (hunk, &first0, &last0, &first1, &last1);
-  if (!changes)
-    return;
-
-  /* Print out lines up to this change.  */
-  print_sdiff_common_lines (first0, first1);
-
-  if (sdiff_merge_assist)
-    {
-      long int len0 = last0 - first0 + 1;
-      long int len1 = last1 - first1 + 1;
-      fprintf (outfile, "c%ld,%ld\n", len0, len1);
-    }
-
-  /* Print ``xxx  |  xxx '' lines */
-  if (changes == CHANGED)
-    {
-      for (i = first0, j = first1;  i <= last0 && j <= last1;  i++, j++)
-	print_1sdiff_line (&files[0].linbuf[i], '|', &files[1].linbuf[j]);
-      changes = (i <= last0 ? OLD : 0) + (j <= last1 ? NEW : 0);
-      next0 = first0 = i;
-      next1 = first1 = j;
-    }
-
-  /* Print ``     >  xxx '' lines */
-  if (changes & NEW)
-    {
-      for (j = first1; j <= last1; ++j)
-	print_1sdiff_line (0, '>', &files[1].linbuf[j]);
-      next1 = j;
-    }
-
-  /* Print ``xxx  <     '' lines */
-  if (changes & OLD)
-    {
-      for (i = first0; i <= last0; ++i)
-	print_1sdiff_line (&files[0].linbuf[i], '<', 0);
-      next0 = i;
-    }
-}
diff --git a/src/util.c b/src/util.c
index 3be03e9..d780217 100644
--- a/src/util.c
+++ b/src/util.c
@@ -27,7 +27,7 @@
 char const pr_program[] = PR_PROGRAM;
 
 /* Queue up one-line messages to be printed at the end,
-   when -l is specified.  Each message is recorded with a `struct msg'.  */
+   when -l is specified.  Each message is recorded with a 'struct msg'.  */
 
 struct msg
 {
@@ -121,7 +121,7 @@ message5 (char const *format_msgid, char const *arg1, char const *arg2,
     }
 }
 
-/* Output all the messages that were saved up by calls to `message'.  */
+/* Output all the messages that were saved up by calls to 'message'.  */
 
 void
 print_message_queue (void)
@@ -146,8 +146,8 @@ print_message_queue (void)
    to set up OUTFILE, the stdio stream for the output to go to.
 
    Usually, OUTFILE is just stdout.  But when -l was specified
-   we fork off a `pr' and make OUTFILE a pipe to it.
-   `pr' then outputs to our stdout.  */
+   we fork off a 'pr' and make OUTFILE a pipe to it.
+   'pr' then outputs to our stdout.  */
 
 static char const *current_name0;
 static char const *current_name1;
@@ -190,7 +190,7 @@ begin_output (void)
       if (fflush (stdout) != 0)
 	pfatal_with_name (_("write failed"));
 
-      /* Make OUTFILE a pipe to a subsidiary `pr'.  */
+      /* Make OUTFILE a pipe to a subsidiary 'pr'.  */
       {
 #if HAVE_WORKING_FORK || HAVE_WORKING_VFORK
 	int pipes[2];
@@ -241,7 +241,7 @@ begin_output (void)
   else
     {
 
-      /* If -l was not specified, output the diff straight to `stdout'.  */
+      /* If -l was not specified, output the diff straight to 'stdout'.  */
 
       outfile = stdout;
 
@@ -270,7 +270,7 @@ begin_output (void)
 }
 
 /* Call after the end of output of diffs for one file.
-   Close OUTFILE and get rid of the `pr' subfork.  */
+   Close OUTFILE and get rid of the 'pr' subfork.  */
 
 void
 finish_output (void)
@@ -650,7 +650,7 @@ print_number_range (char sepchar, struct file_data *file, lin a, lin b)
 
 /* Look at a hunk of edit script and report the range of lines in each file
    that it applies to.  HUNK is the start of the hunk, which is a chain
-   of `struct change'.  The first and last line numbers of file 0 are stored in
+   of 'struct change'.  The first and last line numbers of file 0 are stored in
    *FIRST0 and *LAST0, and likewise for file 1 in *FIRST1 and *LAST1.
    Note that these are internal line numbers that count from 0.
 
